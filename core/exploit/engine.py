#!/usr/bin/env python3
"""
engine.py - 漏洞自动利用引擎

ExploitEngine: 根据检测结果自动选择利用策略并执行

警告: 本工具仅用于授权安全测试，禁止用于未授权的渗透测试活动
"""

import asyncio
import logging
import threading
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Set, Type

logger = logging.getLogger(__name__)

# 允许的参数键白名单
ALLOWED_TARGET_KEYS: Set[str] = {
    "queries",
    "extract_tables",
    "extract_columns",
    "commands",
    "files",
    "internal_targets",
    "timeout",
    "max_depth",
    "verify_ssl",
}


class ExploitType(Enum):
    """利用类型枚举"""

    DATA_EXTRACTION = "data_extraction"
    FILE_READ = "file_read"
    FILE_WRITE = "file_write"
    COMMAND_EXECUTION = "command_execution"
    INTERNAL_ACCESS = "internal_access"
    CODE_INJECTION = "code_injection"
    SESSION_HIJACK = "session_hijack"


class ExploitStatus(Enum):
    """利用状态枚举"""

    SUCCESS = "success"
    PARTIAL = "partial"
    FAILED = "failed"
    NOT_APPLICABLE = "not_applicable"
    REQUIRES_INTERACTION = "requires_interaction"


@dataclass
class ShellInfo:
    """Shell 信息"""

    shell_type: str = "unknown"
    os_type: str = "unknown"
    user: str = ""
    privileges: List[str] = field(default_factory=list)
    shell_path: str = ""
    verified: bool = False

    def to_dict(self) -> Dict[str, Any]:
        return {
            "shell_type": self.shell_type,
            "os_type": self.os_type,
            "user": self.user,
            "privileges": self.privileges,
            "shell_path": self.shell_path,
            "verified": self.verified,
        }


@dataclass
class AccessInfo:
    """内网访问信息"""

    target: str = ""
    protocol: str = ""
    response_content: str = ""
    accessible_resources: List[str] = field(default_factory=list)
    metadata_found: Dict[str, str] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "target": self.target,
            "protocol": self.protocol,
            "response_content": self.response_content[:1000],
            "accessible_resources": self.accessible_resources,
            "metadata_found": self.metadata_found,
        }


@dataclass
class FileInfo:
    """文件信息"""

    path: str = ""
    content: str = ""
    size: int = 0
    file_type: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "path": self.path,
            "content": self.content[:5000],
            "size": self.size,
            "file_type": self.file_type,
        }


@dataclass
class ExploitResult:
    """利用结果"""

    status: ExploitStatus
    exploit_type: ExploitType
    vuln_type: str
    url: str

    data: Optional[Dict[str, Any]] = None
    shell: Optional[ShellInfo] = None
    access: Optional[AccessInfo] = None
    files: Optional[List[FileInfo]] = None

    evidence: str = ""
    payload_used: str = ""
    execution_time_ms: float = 0.0
    exploiter: str = ""
    error: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())

    def to_dict(self) -> Dict[str, Any]:
        return {
            "status": self.status.value,
            "exploit_type": self.exploit_type.value,
            "vuln_type": self.vuln_type,
            "url": self.url,
            "data": self.data,
            "shell": self.shell.to_dict() if self.shell else None,
            "access": self.access.to_dict() if self.access else None,
            "files": [f.to_dict() for f in self.files] if self.files else None,
            "evidence": self.evidence,
            "payload_used": self.payload_used,
            "execution_time_ms": self.execution_time_ms,
            "exploiter": self.exploiter,
            "error": self.error,
            "metadata": self.metadata,
            "timestamp": self.timestamp,
        }

    @property
    def success(self) -> bool:
        return self.status in (ExploitStatus.SUCCESS, ExploitStatus.PARTIAL)


class BaseExploiter(ABC):
    """利用器基类"""

    name: str = "base_exploiter"
    supported_vuln_types: List[str] = []
    exploit_type: ExploitType = ExploitType.DATA_EXTRACTION

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {}
        self._http_client = None
        self._exploit_http_client = None

    @property
    def http_client(self):
        """获取通用HTTP客户端（向后兼容）"""
        if self._http_client is None:
            try:
                from core.http import get_client

                self._http_client = get_client()
            except ImportError:
                # core.http 不可用时，使用 requests 作为回退
                import requests

                self._http_client = requests.Session()
        return self._http_client

    @property
    def exploit_http(self):
        """获取Exploit专用HTTP客户端

        统一的HTTP请求封装，提供：
        - send_get_with_payload(url, param, payload, timeout)
        - send_post_with_payload(url, data, content_type, timeout)
        - send_xml_request(url, xml_payload, timeout)
        - send_ssrf_request(url, param, target_url, timeout)
        """
        if self._exploit_http_client is None:
            try:
                from core.exploit.exploiters.http_utils import ExploitHTTPClient

                self._exploit_http_client = ExploitHTTPClient(self.config)
            except ImportError:
                logger.warning("[BaseExploiter] http_utils不可用，使用回退方案")
                self._exploit_http_client = None
        return self._exploit_http_client

    @abstractmethod
    def exploit(self, detection_result: Any, **kwargs) -> ExploitResult:
        """执行利用"""

    async def async_exploit(self, detection_result: Any, **kwargs) -> ExploitResult:
        """异步执行利用"""
        return await asyncio.to_thread(self.exploit, detection_result, **kwargs)

    def can_exploit(self, detection_result: Any) -> bool:
        """判断是否可以利用"""
        if not getattr(detection_result, "vulnerable", False):
            return False
        return getattr(detection_result, "vuln_type", "") in self.supported_vuln_types

    def _create_result(self, status: ExploitStatus, **kwargs) -> ExploitResult:
        """创建标准化的利用结果"""
        return ExploitResult(
            status=status, exploit_type=self.exploit_type, exploiter=self.name, **kwargs
        )


class ExploitStrategyRegistry:
    """利用策略注册表"""

    _registry: Dict[str, List[Type[BaseExploiter]]] = {}

    VULN_TO_EXPLOIT_TYPE: Dict[str, ExploitType] = {
        "sqli": ExploitType.DATA_EXTRACTION,
        "rce": ExploitType.COMMAND_EXECUTION,
        "ssti": ExploitType.CODE_INJECTION,
        "ldap": ExploitType.DATA_EXTRACTION,
        "xxe": ExploitType.FILE_READ,
        "path_traversal": ExploitType.FILE_READ,
        "lfi": ExploitType.FILE_READ,
        "file_upload": ExploitType.FILE_WRITE,
        "ssrf": ExploitType.INTERNAL_ACCESS,
        "idor": ExploitType.DATA_EXTRACTION,
        "xss": ExploitType.SESSION_HIJACK,
    }

    DEFAULT_TARGETS: Dict[str, Dict[str, Any]] = {
        "sqli": {
            "queries": ["SELECT user()", "SELECT database()", "SELECT @@version"],
            "extract_tables": True,
            "extract_columns": True,
        },
        "rce": {
            "commands": {
                "unix": ["id", "whoami", "uname -a"],
                "windows": ["whoami", "hostname", "systeminfo"],
            },
        },
        "xxe": {
            "files": {
                "unix": ["/etc/passwd", "/etc/hosts"],
                "windows": ["C:\\Windows\\win.ini"],
            },
        },
        "path_traversal": {
            "files": {
                "unix": ["/etc/passwd", "/etc/shadow"],
                "windows": ["..\\..\\..\\..\\windows\\win.ini"],
            },
        },
        "ssrf": {
            "internal_targets": [
                "http://127.0.0.1:80/",
                "http://169.254.169.254/latest/meta-data/",
                "http://localhost:8080/",
            ],
        },
    }

    @classmethod
    def register(cls, vuln_type: str, exploiter_class: Type[BaseExploiter]) -> None:
        """注册利用器"""
        if vuln_type not in cls._registry:
            cls._registry[vuln_type] = []
        if exploiter_class not in cls._registry[vuln_type]:
            cls._registry[vuln_type].append(exploiter_class)

    @classmethod
    def get_exploiters(cls, vuln_type: str) -> List[Type[BaseExploiter]]:
        """获取指定漏洞类型的利用器列表"""
        return cls._registry.get(vuln_type, [])

    @classmethod
    def get_exploit_type(cls, vuln_type: str) -> ExploitType:
        """获取漏洞类型对应的利用类型"""
        return cls.VULN_TO_EXPLOIT_TYPE.get(vuln_type, ExploitType.DATA_EXTRACTION)

    @classmethod
    def get_default_targets(cls, vuln_type: str) -> Dict[str, Any]:
        """获取默认利用目标"""
        return cls.DEFAULT_TARGETS.get(vuln_type, {})


def register_exploiter(vuln_types: List[str]):
    """利用器注册装饰器"""

    def decorator(cls: Type[BaseExploiter]):
        for vuln_type in vuln_types:
            ExploitStrategyRegistry.register(vuln_type, cls)
        return cls

    return decorator


class ExploitEngine:
    """漏洞自动利用引擎

    Usage:
        from core.detectors import SQLiDetector
        from core.exploit import ExploitEngine

        detector = SQLiDetector()
        results = detector.detect("https://target.com/search", params={"q": "test"})

        engine = ExploitEngine()
        for result in results:
            if result.vulnerable:
                exploit_result = engine.exploit(result)
                if exploit_result.success:
                    print(f"数据: {exploit_result.data}")

    警告: 本工具仅用于授权安全测试
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None, poc_engine: Optional[Any] = None):
        self.config = config or {}
        self.poc_engine = poc_engine

        self.auto_escalate = self.config.get("auto_escalate", False)
        self.max_data_size = self.config.get("max_data_size", 10 * 1024 * 1024)
        self.timeout = self.config.get("timeout", 60)
        self.verify_exploit = self.config.get("verify_exploit", True)

        self._exploiters: Dict[str, BaseExploiter] = {}
        self._exploiter_lock = threading.Lock()  # 线程安全锁
        logger.info("[ExploitEngine] 初始化完成")

    def _validate_targets(self, targets: Optional[Dict[str, Any]]) -> Dict[str, Any]:
        """验证并过滤targets参数，防止注入攻击"""
        if targets is None:
            return {}

        validated = {}
        for key, value in targets.items():
            # 只允许白名单中的键
            if key not in ALLOWED_TARGET_KEYS:
                logger.warning("[ExploitEngine] 忽略未授权的参数键: %s", key)
                continue

            # 验证值类型
            if key in ("queries", "files", "internal_targets") and isinstance(value, list):
                # 过滤列表中的危险字符
                validated[key] = [
                    str(v)[:1000]
                    for v in value  # 限制长度防止DoS
                    if isinstance(v, (str, int, float))
                ]
            elif key in ("extract_tables", "extract_columns", "verify_ssl") and isinstance(
                value, bool
            ):
                validated[key] = value
            elif key == "commands" and isinstance(value, dict):
                # 命令参数需要特别小心
                validated[key] = {
                    k: [str(c)[:200] for c in v if isinstance(c, str)]
                    for k, v in value.items()
                    if k in ("unix", "windows") and isinstance(v, list)
                }
            elif key in ("timeout", "max_depth") and isinstance(value, (int, float)):
                validated[key] = min(value, 300)  # 最大300秒/层
            else:
                validated[key] = value

        return validated

    def exploit(
        self, detection_result: Any, targets: Optional[Dict[str, Any]] = None, **kwargs
    ) -> ExploitResult:
        """利用检测到的漏洞"""
        import time

        start_time = time.time()

        if not getattr(detection_result, "vulnerable", False):
            return ExploitResult(
                status=ExploitStatus.NOT_APPLICABLE,
                exploit_type=ExploitType.DATA_EXTRACTION,
                vuln_type=getattr(detection_result, "vuln_type", "unknown"),
                url=getattr(detection_result, "url", ""),
                error="检测结果未发现漏洞",
            )

        vuln_type = getattr(detection_result, "vuln_type", "unknown")

        exploiter = self._get_exploiter(vuln_type)
        if not exploiter:
            return ExploitResult(
                status=ExploitStatus.NOT_APPLICABLE,
                exploit_type=ExploitStrategyRegistry.get_exploit_type(vuln_type),
                vuln_type=vuln_type,
                url=getattr(detection_result, "url", ""),
                error=f"不支持的漏洞类型: {vuln_type}",
            )

        default_targets = ExploitStrategyRegistry.get_default_targets(vuln_type)
        # 验证用户输入的targets参数
        validated_targets = self._validate_targets(targets)
        final_targets = {**default_targets, **validated_targets}

        try:
            result = exploiter.exploit(detection_result, targets=final_targets, **kwargs)
            result.execution_time_ms = (time.time() - start_time) * 1000

            if self.verify_exploit and result.success:
                result = self._verify_result(result)

            return result

        except Exception as e:
            logger.exception("[ExploitEngine] 利用失败: %s", e)
            return ExploitResult(
                status=ExploitStatus.FAILED,
                exploit_type=ExploitStrategyRegistry.get_exploit_type(vuln_type),
                vuln_type=vuln_type,
                url=getattr(detection_result, "url", ""),
                error=str(e),
                execution_time_ms=(time.time() - start_time) * 1000,
            )

    async def async_exploit(
        self, detection_result: Any, targets: Optional[Dict[str, Any]] = None, **kwargs
    ) -> ExploitResult:
        """异步利用漏洞"""
        return await asyncio.to_thread(self.exploit, detection_result, targets, **kwargs)

    def exploit_cve(self, target: str, cve_id: str, **kwargs) -> ExploitResult:
        """利用已知 CVE"""
        if not self.poc_engine:
            try:
                from core.cve.poc_engine import get_poc_engine

                self.poc_engine = get_poc_engine()
            except ImportError:
                return ExploitResult(
                    status=ExploitStatus.NOT_APPLICABLE,
                    exploit_type=ExploitType.COMMAND_EXECUTION,
                    vuln_type=f"cve:{cve_id}",
                    url=target,
                    error="PoC引擎不可用",
                )

        try:
            poc_result = self.poc_engine.execute(target, cve_id, kwargs.get("variables"))

            return ExploitResult(
                status=(
                    ExploitStatus.SUCCESS if poc_result.get("vulnerable") else ExploitStatus.FAILED
                ),
                exploit_type=ExploitType.COMMAND_EXECUTION,
                vuln_type=f"cve:{cve_id}",
                url=target,
                evidence=poc_result.get("evidence", ""),
                payload_used=str(poc_result.get("request", "")),
                data=poc_result.get("extracted"),
                metadata={
                    "template_id": poc_result.get("template_id"),
                    "matcher_name": poc_result.get("matcher_name"),
                },
            )
        except Exception as e:
            return ExploitResult(
                status=ExploitStatus.FAILED,
                exploit_type=ExploitType.COMMAND_EXECUTION,
                vuln_type=f"cve:{cve_id}",
                url=target,
                error=str(e),
            )

    def _get_exploiter(self, vuln_type: str) -> Optional[BaseExploiter]:
        """获取利用器实例 - 线程安全"""
        # 先检查缓存（无锁快速路径）
        if vuln_type in self._exploiters:
            return self._exploiters[vuln_type]

        # 加锁创建新实例
        with self._exploiter_lock:
            # 双重检查，避免重复创建
            if vuln_type in self._exploiters:
                return self._exploiters[vuln_type]

            exploiter_classes = ExploitStrategyRegistry.get_exploiters(vuln_type)
            if not exploiter_classes:
                exploiter_classes = ExploitStrategyRegistry.get_exploiters("generic")

            if not exploiter_classes:
                return None

            exploiter = exploiter_classes[0](self.config)
            self._exploiters[vuln_type] = exploiter
            return exploiter

    def _verify_result(self, result: ExploitResult) -> ExploitResult:
        """验证利用结果"""
        if result.exploit_type == ExploitType.COMMAND_EXECUTION:
            if result.shell and result.shell.user:
                result.metadata["verified"] = True
        elif result.exploit_type == ExploitType.FILE_READ:
            if result.files and any(f.content for f in result.files):
                result.metadata["verified"] = True
        elif result.exploit_type == ExploitType.DATA_EXTRACTION:
            if result.data and len(result.data) > 0:
                result.metadata["verified"] = True
        return result


def exploit_vulnerability(detection_result: Any, **kwargs) -> ExploitResult:
    """便捷函数：利用检测到的漏洞"""
    engine = ExploitEngine()
    return engine.exploit(detection_result, **kwargs)


def exploit_cve(target: str, cve_id: str, **kwargs) -> ExploitResult:
    """便捷函数：利用已知 CVE"""
    engine = ExploitEngine()
    return engine.exploit_cve(target, cve_id, **kwargs)


__all__ = [
    "ExploitEngine",
    "ExploitResult",
    "ExploitStatus",
    "ExploitType",
    "BaseExploiter",
    "ShellInfo",
    "AccessInfo",
    "FileInfo",
    "ExploitStrategyRegistry",
    "register_exploiter",
    "exploit_vulnerability",
    "exploit_cve",
]
