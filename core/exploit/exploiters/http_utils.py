#!/usr/bin/env python3
"""
http_utils.py - Exploiter HTTP客户端工具

提供统一的HTTP请求封装，消除各个exploiter中重复的_send_request实现。

Usage:
    from core.exploit.exploiters.http_utils import ExploitHTTPClient

    client = ExploitHTTPClient()
    result = client.send_get_with_payload(url, param, payload, timeout=30)

警告: 本工具仅用于授权安全测试
"""

import logging
from typing import Any, Dict, Optional
from urllib.parse import parse_qs, urlencode, urlparse, urlunparse

logger = logging.getLogger(__name__)

# 默认User-Agent
DEFAULT_USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"


class ExploitHTTPClient:
    """
    Exploiter专用HTTP客户端

    统一处理各类漏洞利用场景的HTTP请求，包括：
    - GET请求参数注入
    - POST请求数据注入
    - XML/SOAP请求
    - 自定义Content-Type
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        初始化HTTP客户端

        Args:
            config: 配置选项
                - verify_ssl: 是否验证SSL证书 (默认 False)
                - allow_redirects: 是否允许重定向 (默认 True)
                - default_timeout: 默认超时时间 (默认 30秒)
                - user_agent: 自定义User-Agent
                - extra_headers: 额外的请求头
        """
        self.config = config or {}
        self.verify_ssl = self.config.get("verify_ssl", False)
        self.allow_redirects = self.config.get("allow_redirects", True)
        self.default_timeout = self.config.get("default_timeout", 30)
        self.user_agent = self.config.get("user_agent", DEFAULT_USER_AGENT)
        self.extra_headers = self.config.get("extra_headers", {})

        # 懒加载requests模块
        self._session = None

    @property
    def session(self):
        """懒加载requests.Session"""
        if self._session is None:
            import requests

            self._session = requests.Session()
            self._session.verify = self.verify_ssl
        return self._session

    def _get_default_headers(self) -> Dict[str, str]:
        """获取默认请求头"""
        headers = {
            "User-Agent": self.user_agent,
        }
        headers.update(self.extra_headers)
        return headers

    def _build_url_with_param(self, url: str, param: str, payload: str) -> str:
        """
        构建带有payload参数的URL

        Args:
            url: 原始URL
            param: 参数名
            payload: payload值

        Returns:
            构建后的URL
        """
        parsed = urlparse(url)
        params = parse_qs(parsed.query, keep_blank_values=True)

        # 设置payload参数
        params[param] = [payload]

        # 重建URL
        new_query = urlencode(params, doseq=True)
        new_url = urlunparse(
            (parsed.scheme, parsed.netloc, parsed.path, parsed.params, new_query, parsed.fragment)
        )

        return new_url

    def send_get_with_payload(
        self,
        url: str,
        param: str,
        payload: str,
        timeout: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -> Dict[str, Any]:
        """
        发送带payload的GET请求

        Args:
            url: 目标URL
            param: 注入参数名
            payload: payload值
            timeout: 请求超时时间（秒）
            headers: 额外的请求头

        Returns:
            dict: 包含以下字段
                - success: bool, 请求是否成功
                - response: str, 响应内容（成功时）
                - status_code: int, HTTP状态码（成功时）
                - headers: dict, 响应头（成功时）
                - error: str, 错误信息（失败时）
        """
        try:
            import requests

            # 构建URL
            target_url = self._build_url_with_param(url, param, payload)

            # 构建请求头
            request_headers = self._get_default_headers()
            if headers:
                request_headers.update(headers)

            # 发送请求
            response = requests.get(
                target_url,
                timeout=timeout or self.default_timeout,
                verify=self.verify_ssl,
                allow_redirects=self.allow_redirects,
                headers=request_headers,
            )

            return {
                "success": True,
                "response": response.text,
                "status_code": response.status_code,
                "headers": dict(response.headers),
            }

        except requests.exceptions.Timeout:
            return {"success": False, "error": "timeout"}
        except requests.exceptions.ConnectionError:
            return {"success": False, "error": "connection_error"}
        except Exception as e:
            logger.debug("[ExploitHTTPClient] GET请求异常: %s", e)
            return {"success": False, "error": str(e)}

    def send_post_with_payload(
        self,
        url: str,
        data: Dict[str, Any],
        content_type: Optional[str] = None,
        timeout: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -> Dict[str, Any]:
        """
        发送带payload的POST请求

        Args:
            url: 目标URL
            data: POST数据字典
            content_type: Content-Type头（可选）
            timeout: 请求超时时间（秒）
            headers: 额外的请求头

        Returns:
            dict: 同 send_get_with_payload
        """
        try:
            import requests

            # 构建请求头
            request_headers = self._get_default_headers()
            if content_type:
                request_headers["Content-Type"] = content_type
            if headers:
                request_headers.update(headers)

            # 发送请求
            response = requests.post(
                url,
                data=data,
                timeout=timeout or self.default_timeout,
                verify=self.verify_ssl,
                allow_redirects=self.allow_redirects,
                headers=request_headers,
            )

            return {
                "success": True,
                "response": response.text,
                "status_code": response.status_code,
                "headers": dict(response.headers),
            }

        except requests.exceptions.Timeout:
            return {"success": False, "error": "timeout"}
        except requests.exceptions.ConnectionError:
            return {"success": False, "error": "connection_error"}
        except Exception as e:
            logger.debug("[ExploitHTTPClient] POST请求异常: %s", e)
            return {"success": False, "error": str(e)}

    def send_xml_request(
        self,
        url: str,
        xml_payload: str,
        timeout: Optional[int] = None,
        content_type: str = "application/xml",
        headers: Optional[Dict[str, str]] = None,
    ) -> Dict[str, Any]:
        """
        发送XML请求（用于XXE等漏洞利用）

        Args:
            url: 目标URL
            xml_payload: XML payload字符串
            timeout: 请求超时时间（秒）
            content_type: Content-Type头（默认 application/xml）
            headers: 额外的请求头

        Returns:
            dict: 同 send_get_with_payload
        """
        try:
            import requests

            # 构建请求头
            request_headers = self._get_default_headers()
            request_headers["Content-Type"] = content_type
            if headers:
                request_headers.update(headers)

            # 发送POST请求
            response = requests.post(
                url,
                data=xml_payload,
                timeout=timeout or self.default_timeout,
                verify=self.verify_ssl,
                allow_redirects=self.allow_redirects,
                headers=request_headers,
            )

            return {
                "success": True,
                "response": response.text,
                "status_code": response.status_code,
                "headers": dict(response.headers),
            }

        except requests.exceptions.Timeout:
            return {"success": False, "error": "timeout"}
        except requests.exceptions.ConnectionError:
            return {"success": False, "error": "connection_error"}
        except Exception as e:
            logger.debug("[ExploitHTTPClient] XML请求异常: %s", e)
            return {"success": False, "error": str(e)}

    def send_ssrf_request(
        self,
        url: str,
        param: str,
        target_url: str,
        timeout: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -> Dict[str, Any]:
        """
        发送SSRF请求

        自动添加云元数据所需的特殊请求头

        Args:
            url: 原始URL
            param: SSRF参数名
            target_url: SSRF目标URL
            timeout: 请求超时时间（秒）
            headers: 额外的请求头

        Returns:
            dict: 同 send_get_with_payload，额外包含 content 字段
        """
        # 添加云元数据所需的headers
        ssrf_headers = {
            "Metadata-Flavor": "Google",  # GCP
            "X-aws-ec2-metadata-token-ttl-seconds": "21600",  # AWS IMDSv2
        }
        if headers:
            ssrf_headers.update(headers)

        result = self.send_get_with_payload(url, param, target_url, timeout, ssrf_headers)

        # SSRF请求的响应内容也存为 content 字段，保持向后兼容
        if result.get("success"):
            result["content"] = result.get("response", "")

        return result

    def send_raw_request(
        self,
        method: str,
        url: str,
        data: Optional[Any] = None,
        timeout: Optional[int] = None,
        headers: Optional[Dict[str, str]] = None,
    ) -> Dict[str, Any]:
        """
        发送原始HTTP请求（支持任意方法）

        Args:
            method: HTTP方法 (GET, POST, PUT, DELETE, etc.)
            url: 目标URL
            data: 请求数据
            timeout: 请求超时时间（秒）
            headers: 请求头

        Returns:
            dict: 同 send_get_with_payload
        """
        try:
            import requests

            # 构建请求头
            request_headers = self._get_default_headers()
            if headers:
                request_headers.update(headers)

            # 发送请求
            response = requests.request(
                method=method.upper(),
                url=url,
                data=data,
                timeout=timeout or self.default_timeout,
                verify=self.verify_ssl,
                allow_redirects=self.allow_redirects,
                headers=request_headers,
            )

            return {
                "success": True,
                "response": response.text,
                "status_code": response.status_code,
                "headers": dict(response.headers),
            }

        except requests.exceptions.Timeout:
            return {"success": False, "error": "timeout"}
        except requests.exceptions.ConnectionError:
            return {"success": False, "error": "connection_error"}
        except Exception as e:
            logger.debug("[ExploitHTTPClient] %s请求异常: %s", method, e)
            return {"success": False, "error": str(e)}

    def close(self):
        """关闭HTTP会话"""
        if self._session:
            self._session.close()
            self._session = None

    def __enter__(self):
        return self

    def __exit__(self, exc_type, _exc_val, _exc_tb):
        self.close()


# 全局单例实例（可选使用）
_default_client: Optional[ExploitHTTPClient] = None


def get_exploit_http_client(config: Optional[Dict[str, Any]] = None) -> ExploitHTTPClient:
    """
    获取ExploitHTTPClient实例

    Args:
        config: 配置选项（如果提供则创建新实例）

    Returns:
        ExploitHTTPClient实例
    """
    global _default_client

    if config:
        return ExploitHTTPClient(config)

    if _default_client is None:
        _default_client = ExploitHTTPClient()

    return _default_client


__all__ = [
    "ExploitHTTPClient",
    "get_exploit_http_client",
    "DEFAULT_USER_AGENT",
]
