"""
漏洞利用编排器 - 编排多漏洞利用流程

功能:
- 检测结果排序和选择 (按severity/confidence)
- TOP N 并行/顺序利用
- 验证后利用 (集成 VulnerabilityVerifier)
- 与 FeedbackLoopEngine 集成实现自动重试

示例用法:
    from core.exploit.orchestrator import ExploitOrchestrator

    orchestrator = ExploitOrchestrator()
    result = await orchestrator.orchestrate(
        detections=detection_results,
        top_n=3,
        verify_first=True,
        parallel=True
    )

警告: 本工具仅用于授权安全测试
"""

import asyncio
import logging
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from .engine import (
    ExploitEngine,
    ExploitResult,
    ExploitStatus,
    ExploitStrategyRegistry,
    ExploitType,
)

logger = logging.getLogger(__name__)


class OrchestrationStrategy(Enum):
    """编排策略"""

    PARALLEL = "parallel"  # 并行执行
    SEQUENTIAL = "sequential"  # 顺序执行
    PRIORITY_FIRST = "priority_first"  # 优先级优先 (高优先级先执行)
    BREADTH_FIRST = "breadth_first"  # 广度优先 (每类漏洞各取一个)


@dataclass
class OrchestratedExploitResult:
    """编排执行结果"""

    success: bool  # 是否有成功的利用
    total_detections: int  # 总检测数
    attempted: int  # 尝试利用数
    successful: int  # 成功数
    failed: int  # 失败数
    skipped: int  # 跳过数

    # 详细结果
    results: List[ExploitResult] = field(default_factory=list)
    successful_results: List[ExploitResult] = field(default_factory=list)
    failed_results: List[ExploitResult] = field(default_factory=list)

    # 元数据
    total_time_ms: float = 0.0
    strategy: str = ""
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())

    def to_dict(self) -> Dict[str, Any]:
        """转换为字典"""
        return {
            "success": self.success,
            "total_detections": self.total_detections,
            "attempted": self.attempted,
            "successful": self.successful,
            "failed": self.failed,
            "skipped": self.skipped,
            "results": [r.to_dict() for r in self.results],
            "successful_results": [r.to_dict() for r in self.successful_results],
            "total_time_ms": self.total_time_ms,
            "strategy": self.strategy,
            "timestamp": self.timestamp,
        }


@dataclass
class RankedDetection:
    """排序后的检测结果"""

    detection: Any  # 原始检测结果
    score: float  # 综合评分
    rank: int  # 排名
    reason: str  # 排序原因


class ExploitOrchestrator:
    """漏洞利用编排器"""

    # 严重程度权重
    SEVERITY_WEIGHTS = {
        "CRITICAL": 1.0,
        "HIGH": 0.8,
        "MEDIUM": 0.5,
        "LOW": 0.3,
        "INFO": 0.1,
    }

    # 漏洞类型影响权重 (利用价值)
    VULN_TYPE_WEIGHTS = {
        "rce": 1.0,  # 命令执行 - 最高价值
        "sqli": 0.9,  # SQL注入
        "ssti": 0.85,  # 模板注入
        "deserialize": 0.85,  # 反序列化
        "xxe": 0.8,  # XXE
        "ssrf": 0.75,  # SSRF
        "lfi": 0.7,  # 本地文件包含
        "path_traversal": 0.7,
        "file_upload": 0.65,  # 文件上传
        "idor": 0.5,  # IDOR
        "xss": 0.4,  # XSS
    }

    def __init__(
        self,
        exploit_engine: Optional[ExploitEngine] = None,
        feedback_engine: Optional[Any] = None,
        verifier: Optional[Any] = None,
        config: Optional[Dict[str, Any]] = None,
    ):
        """
        初始化编排器

        Args:
            exploit_engine: 利用引擎实例
            feedback_engine: 反馈循环引擎实例
            verifier: 漏洞验证器实例
            config: 配置选项
        """
        self.config = config or {}
        self.exploit_engine = exploit_engine
        self.feedback_engine = feedback_engine
        self.verifier = verifier

        # 配置
        self.default_top_n = self.config.get("default_top_n", 5)
        self.verify_first = self.config.get("verify_first", True)
        self.use_feedback = self.config.get("use_feedback", True)
        self.max_retries = self.config.get("max_retries", 3)
        self.parallel_limit = self.config.get("parallel_limit", 5)

        logger.info("[ExploitOrchestrator] 初始化完成")

    def _get_exploit_engine(self) -> ExploitEngine:
        """获取利用引擎"""
        if self.exploit_engine is None:
            self.exploit_engine = ExploitEngine(self.config)
        return self.exploit_engine

    def _get_feedback_engine(self) -> Any:
        """获取反馈循环引擎"""
        if self.feedback_engine is None:
            try:
                from core.feedback import FeedbackLoopEngine

                self.feedback_engine = FeedbackLoopEngine(max_retries=self.max_retries)
            except ImportError:
                logger.warning("[ExploitOrchestrator] 反馈循环引擎不可用")
                self.feedback_engine = None
        return self.feedback_engine

    def _get_verifier(self) -> Any:
        """获取漏洞验证器"""
        if self.verifier is None:
            try:
                from modules.vuln_verifier import VulnerabilityVerifier

                self.verifier = VulnerabilityVerifier()
            except ImportError:
                logger.warning("[ExploitOrchestrator] 漏洞验证器不可用")
                self.verifier = None
        return self.verifier

    async def orchestrate(
        self,
        detections: List[Any],
        top_n: Optional[int] = None,
        verify_first: Optional[bool] = None,
        parallel: bool = True,
        strategy: OrchestrationStrategy = OrchestrationStrategy.PRIORITY_FIRST,
        targets: Optional[Dict[str, Any]] = None,
    ) -> OrchestratedExploitResult:
        """
        编排多漏洞利用流程

        Args:
            detections: 检测结果列表
            top_n: 最多尝试利用的漏洞数量
            verify_first: 利用前是否先验证
            parallel: 是否并行执行
            strategy: 编排策略
            targets: 传递给利用器的目标参数

        Returns:
            OrchestratedExploitResult 编排结果
        """
        import time

        start_time = time.time()

        top_n = top_n if top_n is not None else self.default_top_n
        verify_first = verify_first if verify_first is not None else self.verify_first

        # 1. 过滤和排序检测结果
        ranked = self._filter_and_rank(detections)
        total_detections = len(detections)
        filtered_count = len(ranked)

        logger.info(
            f"[ExploitOrchestrator] 过滤后 {filtered_count}/{total_detections} 个漏洞, "
            f"TOP {top_n}"
        )

        if not ranked:
            return OrchestratedExploitResult(
                success=False,
                total_detections=total_detections,
                attempted=0,
                successful=0,
                failed=0,
                skipped=total_detections,
                strategy=strategy.value,
                total_time_ms=(time.time() - start_time) * 1000,
            )

        # 2. 选择TOP N
        selected = self._select_by_strategy(ranked, top_n, strategy)
        skipped = total_detections - len(selected)

        logger.info(f"[ExploitOrchestrator] 选择 {len(selected)} 个漏洞进行利用")

        # 3. 可选验证
        if verify_first:
            selected = await self._verify_detections(selected)
            logger.info(f"[ExploitOrchestrator] 验证后剩余 {len(selected)} 个漏洞")

        # 4. 执行利用
        if parallel and len(selected) > 1:
            results = await self._exploit_parallel(selected, targets)
        else:
            results = await self._exploit_sequential(selected, targets)

        # 5. 汇总结果
        successful_results = [r for r in results if r.success]
        failed_results = [r for r in results if not r.success]

        return OrchestratedExploitResult(
            success=len(successful_results) > 0,
            total_detections=total_detections,
            attempted=len(results),
            successful=len(successful_results),
            failed=len(failed_results),
            skipped=skipped,
            results=results,
            successful_results=successful_results,
            failed_results=failed_results,
            strategy=strategy.value,
            total_time_ms=(time.time() - start_time) * 1000,
        )

    def _filter_and_rank(self, detections: List[Any]) -> List[RankedDetection]:
        """过滤并排序检测结果"""
        ranked = []

        for detection in detections:
            # 过滤非漏洞
            if not getattr(detection, "vulnerable", False):
                continue

            # 计算评分
            score = self._calculate_score(detection)
            reason = self._get_ranking_reason(detection, score)

            ranked.append(
                RankedDetection(detection=detection, score=score, rank=0, reason=reason)  # 稍后填充
            )

        # 按评分排序
        ranked.sort(key=lambda x: x.score, reverse=True)

        # 填充排名
        for i, item in enumerate(ranked):
            item.rank = i + 1

        return ranked

    def _calculate_score(self, detection: Any) -> float:
        """计算检测结果的综合评分"""
        score = 0.0

        # 1. 严重程度因素 (40%)
        severity = getattr(detection, "severity", None)
        if severity:
            severity_name = severity.name if hasattr(severity, "name") else str(severity).upper()
            severity_weight = self.SEVERITY_WEIGHTS.get(severity_name, 0.5)
            score += severity_weight * 0.4

        # 2. 置信度因素 (30%)
        confidence = getattr(detection, "confidence", 0.5)
        score += confidence * 0.3

        # 3. 漏洞类型价值 (20%)
        vuln_type = getattr(detection, "vuln_type", "unknown")
        type_weight = self.VULN_TYPE_WEIGHTS.get(vuln_type, 0.3)
        score += type_weight * 0.2

        # 4. 已验证加分 (10%)
        if getattr(detection, "verified", False):
            score += 0.1

        # 5. 额外因素
        extra = getattr(detection, "extra", {})
        if isinstance(extra, dict):
            # 有可利用的payload加分
            if extra.get("payload"):
                score += 0.05
            # 有注入类型信息加分
            if extra.get("injection_type"):
                score += 0.03
            # 有数据库类型信息加分
            if extra.get("db_type"):
                score += 0.02

        return min(score, 1.0)

    def _get_ranking_reason(self, detection: Any, score: float) -> str:
        """获取排序原因说明"""
        reasons = []

        severity = getattr(detection, "severity", None)
        if severity:
            severity_name = severity.name if hasattr(severity, "name") else str(severity)
            reasons.append(f"严重程度:{severity_name}")

        confidence = getattr(detection, "confidence", 0)
        if confidence > 0:
            reasons.append(f"置信度:{confidence:.2f}")

        vuln_type = getattr(detection, "vuln_type", "")
        if vuln_type:
            reasons.append(f"类型:{vuln_type}")

        if getattr(detection, "verified", False):
            reasons.append("已验证")

        return f"评分:{score:.3f} ({', '.join(reasons)})"

    def _select_by_strategy(
        self, ranked: List[RankedDetection], top_n: int, strategy: OrchestrationStrategy
    ) -> List[RankedDetection]:
        """根据策略选择要利用的检测结果"""
        if strategy == OrchestrationStrategy.PRIORITY_FIRST:
            # 简单取TOP N
            return ranked[:top_n]

        elif strategy == OrchestrationStrategy.BREADTH_FIRST:
            # 每种漏洞类型各取一个，直到达到top_n
            selected = []
            seen_types = set()

            # 第一轮：每类一个
            for item in ranked:
                vuln_type = getattr(item.detection, "vuln_type", "unknown")
                if vuln_type not in seen_types:
                    selected.append(item)
                    seen_types.add(vuln_type)
                    if len(selected) >= top_n:
                        break

            # 第二轮：补充直到达到top_n
            if len(selected) < top_n:
                for item in ranked:
                    if item not in selected:
                        selected.append(item)
                        if len(selected) >= top_n:
                            break

            return selected

        elif strategy == OrchestrationStrategy.PARALLEL:
            # 并行策略：取所有高优先级
            high_priority = [r for r in ranked if r.score >= 0.7]
            if len(high_priority) >= top_n:
                return high_priority[:top_n]
            return ranked[:top_n]

        else:
            # 默认按优先级
            return ranked[:top_n]

    async def _verify_detections(self, ranked: List[RankedDetection]) -> List[RankedDetection]:
        """验证检测结果，过滤误报"""
        verifier = self._get_verifier()
        if not verifier:
            return ranked

        verified = []
        for item in ranked:
            # 已验证的直接通过
            if getattr(item.detection, "verified", False):
                verified.append(item)
                continue

            try:
                # 调用验证器
                if hasattr(verifier, "verify_async"):
                    result = await verifier.verify_async(item.detection)
                elif hasattr(verifier, "verify"):
                    result = await asyncio.to_thread(verifier.verify, item.detection)
                else:
                    # 验证器接口不兼容，跳过验证
                    verified.append(item)
                    continue

                # 检查验证结果
                if isinstance(result, dict):
                    if result.get("verified", False) or result.get("is_valid", False):
                        verified.append(item)
                        logger.debug("[ExploitOrchestrator] 验证通过: %s", item.detection.url)
                    else:
                        logger.debug(
                            f"[ExploitOrchestrator] 验证失败(可能误报): {item.detection.url}"
                        )
                elif result:
                    verified.append(item)

            except Exception as e:
                logger.warning("[ExploitOrchestrator] 验证异常: %s, 保留检测结果", e)
                verified.append(item)  # 验证失败时保守地保留

        return verified

    async def _exploit_parallel(
        self, ranked: List[RankedDetection], targets: Optional[Dict[str, Any]]
    ) -> List[ExploitResult]:
        """并行执行利用"""
        semaphore = asyncio.Semaphore(self.parallel_limit)

        async def exploit_with_limit(item: RankedDetection) -> ExploitResult:
            async with semaphore:
                return await self._exploit_single(item, targets)

        tasks = [exploit_with_limit(item) for item in ranked]
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # 处理异常
        processed = []
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                logger.error("[ExploitOrchestrator] 并行利用异常: %s", result)
                processed.append(
                    ExploitResult(
                        status=ExploitStatus.FAILED,
                        exploit_type=ExploitType.DATA_EXTRACTION,
                        vuln_type=getattr(ranked[i].detection, "vuln_type", "unknown"),
                        url=getattr(ranked[i].detection, "url", ""),
                        error=str(result),
                    )
                )
            else:
                processed.append(result)

        return processed

    async def _exploit_sequential(
        self, ranked: List[RankedDetection], targets: Optional[Dict[str, Any]]
    ) -> List[ExploitResult]:
        """顺序执行利用"""
        results = []
        for item in ranked:
            try:
                result = await self._exploit_single(item, targets)
                results.append(result)

                # 如果成功且配置了早停
                if result.success and self.config.get("stop_on_first_success", False):
                    break

            except Exception as e:
                logger.error("[ExploitOrchestrator] 顺序利用异常: %s", e)
                results.append(
                    ExploitResult(
                        status=ExploitStatus.FAILED,
                        exploit_type=ExploitType.DATA_EXTRACTION,
                        vuln_type=getattr(item.detection, "vuln_type", "unknown"),
                        url=getattr(item.detection, "url", ""),
                        error=str(e),
                    )
                )

        return results

    async def _exploit_single(
        self, item: RankedDetection, targets: Optional[Dict[str, Any]]
    ) -> ExploitResult:
        """利用单个漏洞"""
        detection = item.detection
        engine = self._get_exploit_engine()

        # 决定是否使用反馈循环
        if self.use_feedback:
            feedback = self._get_feedback_engine()
            if feedback:
                return await self._exploit_with_feedback(engine, detection, targets)

        # 直接利用
        return await engine.async_exploit(detection, targets=targets)

    async def _exploit_with_feedback(
        self, engine: ExploitEngine, detection: Any, targets: Optional[Dict[str, Any]]
    ) -> ExploitResult:
        """使用反馈循环执行利用"""
        feedback = self._get_feedback_engine()

        async def exploit_operation(**kwargs) -> ExploitResult:
            det = kwargs.get("detection")
            tgt = kwargs.get("targets")
            return await engine.async_exploit(det, targets=tgt)

        result = await feedback.execute_with_feedback(
            exploit_operation, detection_result=detection, detection=detection, targets=targets
        )

        if result.success:
            return result.result
        else:
            # 构造失败结果
            return ExploitResult(
                status=ExploitStatus.FAILED,
                exploit_type=ExploitStrategyRegistry.get_exploit_type(
                    getattr(detection, "vuln_type", "unknown")
                ),
                vuln_type=getattr(detection, "vuln_type", "unknown"),
                url=getattr(detection, "url", ""),
                error=str(result.final_error) if result.final_error else "反馈循环执行失败",
                metadata={
                    "total_attempts": result.total_attempts,
                    "adjustments_applied": result.adjustments_applied,
                },
            )


# ============== 便捷函数 ==============


async def orchestrate_exploits(
    detections: List[Any],
    top_n: int = 5,
    verify_first: bool = True,
    parallel: bool = True,
    **kwargs,
) -> OrchestratedExploitResult:
    """便捷函数: 编排多漏洞利用"""
    orchestrator = ExploitOrchestrator()
    return await orchestrator.orchestrate(
        detections=detections, top_n=top_n, verify_first=verify_first, parallel=parallel, **kwargs
    )


async def exploit_with_retry(
    detection: Any, max_retries: int = 3, targets: Optional[Dict[str, Any]] = None
) -> ExploitResult:
    """便捷函数: 带重试的单漏洞利用"""
    try:
        from core.feedback import FeedbackLoopEngine

        feedback = FeedbackLoopEngine(max_retries=max_retries)
        engine = ExploitEngine()

        async def exploit_op(**kwargs):
            return await engine.async_exploit(
                kwargs.get("detection"), targets=kwargs.get("targets")
            )

        result = await feedback.execute_with_feedback(
            exploit_op, detection_result=detection, detection=detection, targets=targets
        )

        if result.success:
            return result.result
        else:
            return ExploitResult(
                status=ExploitStatus.FAILED,
                exploit_type=ExploitStrategyRegistry.get_exploit_type(
                    getattr(detection, "vuln_type", "unknown")
                ),
                vuln_type=getattr(detection, "vuln_type", "unknown"),
                url=getattr(detection, "url", ""),
                error=str(result.final_error),
                metadata={
                    "total_attempts": result.total_attempts,
                    "adjustments_applied": result.adjustments_applied,
                },
            )

    except ImportError:
        # 反馈引擎不可用，直接利用
        engine = ExploitEngine()
        return await engine.async_exploit(detection, targets=targets)


__all__ = [
    "ExploitOrchestrator",
    "OrchestratedExploitResult",
    "OrchestrationStrategy",
    "RankedDetection",
    "orchestrate_exploits",
    "exploit_with_retry",
]
