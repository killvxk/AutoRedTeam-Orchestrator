#!/usr/bin/env python3
"""
纯 Python 端口扫描器 - Pure Port Scanner
功能: TCP/UDP 扫描、服务识别、Banner抓取，无需 nmap 依赖
"""

import asyncio
import socket
import struct
import time
import logging
import ipaddress
import ssl
from typing import Dict, List, Optional, Tuple, Any, Set
from dataclasses import dataclass, field
from enum import Enum
from concurrent.futures import ThreadPoolExecutor
import re

logger = logging.getLogger(__name__)


class PortState(Enum):
    """端口状态"""
    OPEN = "open"
    CLOSED = "closed"
    FILTERED = "filtered"
    UNKNOWN = "unknown"


class ScanType(Enum):
    """扫描类型"""
    TCP_CONNECT = "tcp_connect"  # TCP 全连接
    TCP_SYN = "tcp_syn"  # TCP SYN (需要 root)
    UDP = "udp"
    SERVICE = "service"  # 服务识别


@dataclass
class ServiceInfo:
    """服务信息"""
    name: str = "unknown"
    version: str = ""
    banner: str = ""
    product: str = ""
    extra_info: Dict[str, str] = field(default_factory=dict)


@dataclass
class PortResult:
    """端口扫描结果"""
    port: int
    state: PortState
    protocol: str = "tcp"
    service: Optional[ServiceInfo] = None
    response_time: float = 0.0


@dataclass
class HostResult:
    """主机扫描结果"""
    host: str
    ip: str
    is_up: bool = False
    ports: List[PortResult] = field(default_factory=list)
    os_guess: str = ""
    scan_time: float = 0.0


class ServiceProbe:
    """
    服务探测器 - 类似 nmap 的 nmap-service-probes
    """

    # 服务签名库
    SERVICE_SIGNATURES = {
        # HTTP 服务
        "http": {
            "probes": [b"GET / HTTP/1.0\r\n\r\n", b"HEAD / HTTP/1.1\r\nHost: localhost\r\n\r\n"],
            "patterns": [
                (r"HTTP/[\d.]+\s+\d+", "http"),
                (r"Server:\s*([^\r\n]+)", "server"),
                (r"X-Powered-By:\s*([^\r\n]+)", "powered_by"),
            ],
            "ports": [80, 8080, 8000, 8888, 3000, 5000, 8443],
        },
        # SSH 服务
        "ssh": {
            "probes": [b"\r\n"],
            "patterns": [
                (r"SSH-([\d.]+)-([^\r\n]+)", "ssh"),
                (r"OpenSSH[_\s]*([\d.p]+)", "openssh"),
                (r"Dropbear[_\s]*([\d.]+)", "dropbear"),
            ],
            "ports": [22, 2222],
        },
        # FTP 服务
        "ftp": {
            "probes": [b""],
            "patterns": [
                (r"220[- ](.+)", "ftp"),
                (r"vsFTPd\s+([\d.]+)", "vsftpd"),
                (r"ProFTPD\s+([\d.]+)", "proftpd"),
                (r"Pure-FTPd", "pureftpd"),
            ],
            "ports": [21],
        },
        # SMTP 服务
        "smtp": {
            "probes": [b""],
            "patterns": [
                (r"220[- ](.+)", "smtp"),
                (r"Postfix", "postfix"),
                (r"Microsoft ESMTP", "ms_smtp"),
                (r"Sendmail", "sendmail"),
            ],
            "ports": [25, 587, 465],
        },
        # MySQL
        "mysql": {
            "probes": [b""],
            "patterns": [
                (r"mysql_native_password", "mysql"),
                (r"([\d.]+)-MariaDB", "mariadb"),
                (r"([\d.]+)-MySQL", "mysql"),
            ],
            "ports": [3306],
        },
        # PostgreSQL
        "postgresql": {
            "probes": [b"\x00\x00\x00\x08\x04\xd2\x16\x2f"],  # SSLRequest
            "patterns": [
                (r"PostgreSQL", "postgresql"),
            ],
            "ports": [5432],
        },
        # Redis
        "redis": {
            "probes": [b"PING\r\n", b"INFO\r\n"],
            "patterns": [
                (r"\+PONG", "redis"),
                (r"redis_version:([\d.]+)", "redis"),
            ],
            "ports": [6379],
        },
        # MongoDB
        "mongodb": {
            "probes": [b""],
            "patterns": [
                (r"MongoDB", "mongodb"),
                (r"ismaster", "mongodb"),
            ],
            "ports": [27017],
        },
        # RDP
        "rdp": {
            "probes": [b"\x03\x00\x00\x13\x0e\xe0\x00\x00\x00\x00\x00\x01\x00\x08\x00\x03\x00\x00\x00"],
            "patterns": [
                (r"\x03\x00", "rdp"),
            ],
            "ports": [3389],
        },
        # SMB
        "smb": {
            "probes": [
                b"\x00\x00\x00\x85\xff\x53\x4d\x42\x72\x00\x00\x00\x00\x18\x53\xc8"
            ],
            "patterns": [
                (r"SMB", "smb"),
                (r"Windows", "windows_smb"),
            ],
            "ports": [445, 139],
        },
        # DNS
        "dns": {
            "probes": [b"\x00\x1e\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x07version\x04bind\x00\x00\x10\x00\x03"],
            "patterns": [
                (r"bind", "bind"),
            ],
            "ports": [53],
        },
        # LDAP
        "ldap": {
            "probes": [b"\x30\x0c\x02\x01\x01\x60\x07\x02\x01\x03\x04\x00\x80\x00"],
            "patterns": [
                (r"LDAP", "ldap"),
            ],
            "ports": [389, 636],
        },
        # Telnet
        "telnet": {
            "probes": [b""],
            "patterns": [
                (r"login:", "telnet"),
                (r"Welcome", "telnet"),
            ],
            "ports": [23],
        },
    }

    # 常见端口服务映射
    DEFAULT_SERVICES = {
        21: "ftp", 22: "ssh", 23: "telnet", 25: "smtp", 53: "dns",
        80: "http", 110: "pop3", 111: "rpcbind", 135: "msrpc",
        139: "netbios-ssn", 143: "imap", 443: "https", 445: "microsoft-ds",
        993: "imaps", 995: "pop3s", 1433: "ms-sql-s", 1521: "oracle",
        3306: "mysql", 3389: "ms-wbt-server", 5432: "postgresql",
        5900: "vnc", 6379: "redis", 8080: "http-proxy", 8443: "https-alt",
        27017: "mongodb",
    }

    @classmethod
    async def probe_service(cls, host: str, port: int,
                            timeout: float = 5.0) -> ServiceInfo:
        """
        探测服务

        Args:
            host: 目标主机
            port: 端口号
            timeout: 超时时间
        """
        service = ServiceInfo()

        # 1. 首先尝试获取 Banner
        banner = await cls._grab_banner(host, port, timeout)
        if banner:
            service.banner = banner[:500]

        # 2. 尝试匹配已知服务签名
        for svc_name, svc_config in cls.SERVICE_SIGNATURES.items():
            if port in svc_config.get("ports", []) or banner:
                # 发送探测包
                for probe in svc_config["probes"]:
                    response = await cls._send_probe(host, port, probe, timeout)
                    if response:
                        service.banner = response[:500] if not service.banner else service.banner

                        # 匹配模式
                        for pattern, match_type in svc_config["patterns"]:
                            match = re.search(pattern, response, re.IGNORECASE)
                            if match:
                                service.name = svc_name
                                if match.groups():
                                    service.version = match.group(1)
                                return service

        # 3. 使用默认服务映射
        if not service.name or service.name == "unknown":
            service.name = cls.DEFAULT_SERVICES.get(port, "unknown")

        # 4. SSL/TLS 检测
        if await cls._is_ssl(host, port, timeout):
            service.extra_info["ssl"] = "true"
            if service.name == "http":
                service.name = "https"

        return service

    @classmethod
    async def _grab_banner(cls, host: str, port: int,
                           timeout: float) -> Optional[str]:
        """抓取 Banner"""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=timeout
            )

            # 等待服务器发送 Banner
            try:
                banner = await asyncio.wait_for(
                    reader.read(1024),
                    timeout=2.0
                )
                writer.close()
                await writer.wait_closed()
                return banner.decode('utf-8', errors='ignore')
            except asyncio.TimeoutError:
                # 服务器没有主动发送，尝试发送探测
                writer.write(b"\r\n")
                await writer.drain()
                banner = await asyncio.wait_for(reader.read(1024), timeout=2.0)
                writer.close()
                await writer.wait_closed()
                return banner.decode('utf-8', errors='ignore')

        except Exception as e:
            logger.debug(f"Banner grab failed for {host}:{port} - {e}")
            return None

    @classmethod
    async def _send_probe(cls, host: str, port: int, probe: bytes,
                          timeout: float) -> Optional[str]:
        """发送探测包并获取响应"""
        try:
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port),
                timeout=timeout
            )

            if probe:
                writer.write(probe)
                await writer.drain()

            response = await asyncio.wait_for(
                reader.read(2048),
                timeout=timeout
            )

            writer.close()
            await writer.wait_closed()

            return response.decode('utf-8', errors='ignore')

        except Exception as e:
            logger.debug(f"Probe failed for {host}:{port} - {e}")
            return None

    @classmethod
    async def _is_ssl(cls, host: str, port: int, timeout: float) -> bool:
        """检测是否为 SSL/TLS 服务"""
        try:
            ssl_context = ssl.create_default_context()
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE

            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(host, port, ssl=ssl_context),
                timeout=timeout
            )
            writer.close()
            await writer.wait_closed()
            return True

        except Exception:
            return False


class PurePortScanner:
    """
    纯 Python 端口扫描器

    Usage:
        scanner = PurePortScanner()

        # 扫描单个主机
        result = await scanner.scan_host("192.168.1.1", [22, 80, 443, 3306])

        # 扫描网段
        results = await scanner.scan_network("192.168.1.0/24", [22, 80])

        # 快速扫描常见端口
        result = await scanner.quick_scan("192.168.1.1")
    """

    # 常见端口列表
    COMMON_PORTS = [
        21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445,
        993, 995, 1433, 1521, 3306, 3389, 5432, 5900, 6379, 8080, 8443,
        27017, 27018, 6443, 9200, 9300
    ]

    TOP_100_PORTS = [
        7, 9, 13, 21, 22, 23, 25, 26, 37, 53, 79, 80, 81, 88, 106, 110, 111,
        113, 119, 135, 139, 143, 144, 179, 199, 389, 427, 443, 444, 445,
        465, 513, 514, 515, 543, 544, 548, 554, 587, 631, 646, 873, 990,
        993, 995, 1025, 1026, 1027, 1028, 1029, 1110, 1433, 1720, 1723,
        1755, 1900, 2000, 2001, 2049, 2121, 2717, 3000, 3128, 3306, 3389,
        3986, 4899, 5000, 5009, 5051, 5060, 5101, 5190, 5357, 5432, 5631,
        5666, 5800, 5900, 6000, 6001, 6646, 7070, 8000, 8008, 8009, 8080,
        8081, 8443, 8888, 9100, 9999, 10000, 32768, 49152, 49153, 49154,
        49155, 49156, 49157
    ]

    def __init__(self,
                 concurrency: int = 100,
                 timeout: float = 3.0,
                 service_detection: bool = True,
                 retries: int = 1):
        """
        Args:
            concurrency: 并发连接数
            timeout: 连接超时
            service_detection: 是否进行服务识别
            retries: 重试次数
        """
        self.concurrency = concurrency
        self.timeout = timeout
        self.service_detection = service_detection
        self.retries = retries

        self._semaphore: Optional[asyncio.Semaphore] = None

    async def _get_semaphore(self) -> asyncio.Semaphore:
        """获取信号量"""
        if self._semaphore is None:
            self._semaphore = asyncio.Semaphore(self.concurrency)
        return self._semaphore

    async def scan_port(self, host: str, port: int) -> PortResult:
        """
        扫描单个端口

        Args:
            host: 目标主机
            port: 端口号
        """
        semaphore = await self._get_semaphore()

        async with semaphore:
            state = PortState.CLOSED
            response_time = 0.0
            service = None

            for attempt in range(self.retries + 1):
                start_time = time.time()

                try:
                    _, writer = await asyncio.wait_for(
                        asyncio.open_connection(host, port),
                        timeout=self.timeout
                    )
                    response_time = time.time() - start_time

                    # 端口开放
                    state = PortState.OPEN
                    writer.close()
                    await writer.wait_closed()

                    # 服务识别
                    if self.service_detection:
                        service = await ServiceProbe.probe_service(
                            host, port, self.timeout
                        )

                    break

                except asyncio.TimeoutError:
                    state = PortState.FILTERED
                except ConnectionRefusedError:
                    state = PortState.CLOSED
                    break
                except OSError as e:
                    if "Network is unreachable" in str(e):
                        state = PortState.FILTERED
                    else:
                        state = PortState.UNKNOWN
                except Exception as e:
                    logger.debug(f"Port scan error {host}:{port} - {e}")
                    state = PortState.UNKNOWN

            return PortResult(
                port=port,
                state=state,
                protocol="tcp",
                service=service,
                response_time=response_time
            )

    async def scan_host(self, host: str, ports: List[int]) -> HostResult:
        """
        扫描单个主机的多个端口

        Args:
            host: 目标主机
            ports: 端口列表
        """
        start_time = time.time()

        # 解析主机名
        try:
            ip = socket.gethostbyname(host)
        except socket.gaierror:
            return HostResult(host=host, ip="", is_up=False)

        # 首先检查主机是否存活
        is_up = await self._check_host_alive(ip)

        if not is_up:
            return HostResult(host=host, ip=ip, is_up=False)

        # 扫描端口
        tasks = [self.scan_port(ip, port) for port in ports]
        results = await asyncio.gather(*tasks)

        # 过滤开放端口
        open_ports = [r for r in results if r.state == PortState.OPEN]

        return HostResult(
            host=host,
            ip=ip,
            is_up=True,
            ports=results,
            scan_time=time.time() - start_time
        )

    async def scan_network(self, cidr: str, ports: List[int]) -> List[HostResult]:
        """
        扫描网段

        Args:
            cidr: 网段 (如 192.168.1.0/24)
            ports: 端口列表
        """
        try:
            network = ipaddress.ip_network(cidr, strict=False)
        except ValueError as e:
            logger.error(f"Invalid CIDR: {cidr} - {e}")
            return []

        hosts = [str(ip) for ip in network.hosts()]
        results = []

        # 分批扫描
        batch_size = min(50, len(hosts))
        for i in range(0, len(hosts), batch_size):
            batch = hosts[i:i + batch_size]
            tasks = [self.scan_host(h, ports) for h in batch]
            batch_results = await asyncio.gather(*tasks)
            results.extend(batch_results)

            logger.info(f"Scanned {min(i + batch_size, len(hosts))}/{len(hosts)} hosts")

        return results

    async def quick_scan(self, host: str) -> HostResult:
        """快速扫描常见端口"""
        return await self.scan_host(host, self.COMMON_PORTS)

    async def full_scan(self, host: str, port_range: Tuple[int, int] = (1, 65535)) -> HostResult:
        """
        全端口扫描

        Args:
            host: 目标主机
            port_range: 端口范围 (start, end)
        """
        start, end = port_range
        ports = list(range(start, min(end + 1, 65536)))
        return await self.scan_host(host, ports)

    async def _check_host_alive(self, host: str) -> bool:
        """检查主机是否存活"""
        # 尝试连接常见端口
        for port in [80, 443, 22, 445]:
            try:
                _, writer = await asyncio.wait_for(
                    asyncio.open_connection(host, port),
                    timeout=1.0
                )
                writer.close()
                await writer.wait_closed()
                return True
            except Exception:
                continue

        return True  # 即使连接失败也继续扫描

    async def syn_scan(self, host: str, port: int) -> PortState:
        """
        SYN 扫描 (需要 root 权限)

        注意: 纯 Python 实现 SYN 扫描需要 raw socket，
        通常需要 root 权限，这里提供基础实现
        """
        try:
            # 创建 raw socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)
            sock.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
            sock.settimeout(self.timeout)

            # 构造 SYN 包 (简化版)
            # 实际实现需要完整的 TCP/IP 包构造
            logger.warning("SYN scan requires raw socket and root privileges")
            return PortState.UNKNOWN

        except PermissionError:
            logger.error("SYN scan requires root/administrator privileges")
            return PortState.UNKNOWN
        except Exception as e:
            logger.error(f"SYN scan error: {e}")
            return PortState.UNKNOWN


class UDPScanner:
    """UDP 端口扫描器"""

    UDP_PROBES = {
        53: b"\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00",  # DNS
        161: b"\x30\x26\x02\x01\x01\x04\x06public",  # SNMP
        123: b"\xe3\x00\x04\xfa",  # NTP
        137: b"\x80\x94\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00",  # NetBIOS
    }

    def __init__(self, timeout: float = 3.0):
        self.timeout = timeout

    async def scan_port(self, host: str, port: int) -> PortResult:
        """扫描 UDP 端口"""
        try:
            # 创建 UDP socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.settimeout(self.timeout)

            # 获取探测包
            probe = self.UDP_PROBES.get(port, b"\x00")

            sock.sendto(probe, (host, port))

            try:
                data, _ = sock.recvfrom(1024)
                sock.close()
                return PortResult(
                    port=port,
                    state=PortState.OPEN,
                    protocol="udp",
                    service=ServiceInfo(banner=data.decode('utf-8', errors='ignore')[:100])
                )
            except socket.timeout:
                sock.close()
                return PortResult(port=port, state=PortState.FILTERED, protocol="udp")

        except Exception as e:
            logger.debug(f"UDP scan error {host}:{port} - {e}")
            return PortResult(port=port, state=PortState.UNKNOWN, protocol="udp")


# 同步包装器
def run_async(coro):
    """运行异步协程"""
    try:
        loop = asyncio.get_event_loop()
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

    return loop.run_until_complete(coro)


# 便捷函数
def scan_ports(host: str, ports: List[int], concurrency: int = 100) -> Dict[str, Any]:
    """
    扫描端口 (同步接口)

    Usage:
        result = scan_ports("192.168.1.1", [22, 80, 443])
        for port in result["open_ports"]:
            print(f"Port {port['port']} is open - {port['service']}")
    """
    scanner = PurePortScanner(concurrency=concurrency)
    result = run_async(scanner.scan_host(host, ports))

    return {
        "host": result.host,
        "ip": result.ip,
        "is_up": result.is_up,
        "open_ports": [
            {
                "port": p.port,
                "state": p.state.value,
                "service": p.service.name if p.service else "unknown",
                "version": p.service.version if p.service else "",
                "banner": p.service.banner[:100] if p.service and p.service.banner else "",
            }
            for p in result.ports if p.state == PortState.OPEN
        ],
        "total_scanned": len(result.ports),
        "scan_time": result.scan_time,
    }


def scan_network(cidr: str, ports: List[int] = None) -> List[Dict[str, Any]]:
    """
    扫描网段 (同步接口)

    Usage:
        results = scan_network("192.168.1.0/24", [22, 80])
        for host in results:
            if host["is_up"]:
                print(f"{host['ip']} - {len(host['open_ports'])} open ports")
    """
    scanner = PurePortScanner()
    ports = ports or PurePortScanner.COMMON_PORTS

    results = run_async(scanner.scan_network(cidr, ports))

    return [
        {
            "host": r.host,
            "ip": r.ip,
            "is_up": r.is_up,
            "open_ports": [
                {"port": p.port, "service": p.service.name if p.service else "unknown"}
                for p in r.ports if p.state == PortState.OPEN
            ],
        }
        for r in results
    ]


def quick_scan(host: str) -> Dict[str, Any]:
    """快速扫描 (同步接口)"""
    scanner = PurePortScanner()
    result = run_async(scanner.quick_scan(host))

    open_ports = [p for p in result.ports if p.state == PortState.OPEN]

    return {
        "host": result.host,
        "ip": result.ip,
        "is_up": result.is_up,
        "open_ports": [
            {
                "port": p.port,
                "service": p.service.name if p.service else "unknown",
                "banner": p.service.banner[:50] if p.service and p.service.banner else "",
            }
            for p in open_ports
        ],
        "scan_time": f"{result.scan_time:.2f}s",
    }


if __name__ == "__main__":
    import sys

    target = sys.argv[1] if len(sys.argv) > 1 else "127.0.0.1"

    print(f"Scanning {target}...")
    print("=" * 50)

    result = quick_scan(target)

    print(f"Host: {result['host']} ({result['ip']})")
    print(f"Status: {'Up' if result['is_up'] else 'Down'}")
    print(f"Scan Time: {result['scan_time']}")
    print(f"\nOpen Ports ({len(result['open_ports'])}):")

    for port_info in result['open_ports']:
        print(f"  {port_info['port']}/tcp - {port_info['service']}")
        if port_info.get('banner'):
            print(f"    Banner: {port_info['banner']}")
