#!/usr/bin/env python3
"""
phases/exploit.py - 漏洞利用阶段执行器

负责漏洞利用与初始访问获取。
"""

import asyncio
import logging
from typing import TYPE_CHECKING, Any, Dict, List, Optional
from urllib.parse import urlparse

from .base import BasePhaseExecutor, PhaseResult

logger = logging.getLogger(__name__)


class ExploitPhaseExecutor(BasePhaseExecutor):
    """漏洞利用阶段执行器"""

    name = "exploit"
    description = "漏洞利用与初始访问"

    @property
    def phase(self):
        from ..state import PentestPhase

        return PentestPhase.EXPLOIT

    @property
    def required_phases(self):
        from ..state import PentestPhase

        return (PentestPhase.POC_EXEC,)

    async def execute(self) -> PhaseResult:
        from ..state import PentestPhase

        errors: List[str] = []
        findings: List[Dict[str, Any]] = []

        try:
            from core.detectors import DetectionResult
            from core.exploit import ExploitEngine

            from ..state import AccessInfo

            allow_unverified = self.config.get("allow_unverified_exploit", False)
            max_exploits = self._clamp_config_int("max_exploits", 5, 1, 20)
            exploit_targets = self.config.get("exploit_targets")
            prefer_cve = self.config.get("use_cve_exploit", False)

            engine = ExploitEngine(self.config)

            exploitable = []
            for finding in self.state.findings:
                severity = str(finding.get("severity", "")).lower()
                if severity not in ("critical", "high"):
                    continue
                if not allow_unverified and not finding.get("verified"):
                    continue
                if finding.get("exploit_attempted"):
                    continue
                if not finding.get("type"):
                    continue
                exploitable.append(finding)

            exploitable = exploitable[:max_exploits]
            success_count = 0

            for finding in exploitable:
                finding["exploit_attempted"] = True
                target_url = finding.get("url") or self.get_normalized_target()
                severity = str(finding.get("severity", "high")).lower()
                detection_data = {
                    "vulnerable": True,
                    "vuln_type": finding.get("type", ""),
                    "severity": severity if severity else "high",
                    "url": target_url,
                    "param": finding.get("param"),
                    "payload": finding.get("payload"),
                    "evidence": finding.get("evidence"),
                    "verified": finding.get("verified", False),
                    "confidence": finding.get("confidence", 0.0),
                    "references": finding.get("references", []) or [],
                    "extra": {"cve_id": finding.get("cve_id")},
                }

                try:
                    detection_result = DetectionResult.from_dict(detection_data)
                    if prefer_cve and finding.get("cve_id"):
                        exploit_result = await asyncio.to_thread(
                            engine.exploit_cve, target_url, finding.get("cve_id")
                        )
                    else:
                        exploit_result = await engine.async_exploit(
                            detection_result, targets=exploit_targets
                        )

                    finding["exploit_result"] = exploit_result.to_dict()
                    if exploit_result.success:
                        success_count += 1
                        finding["exploited"] = True

                        access_host = target_url
                        parsed = urlparse(target_url)
                        if parsed.netloc:
                            access_host = parsed.netloc

                        extracted_creds = self._extract_credentials_from_exploit(
                            exploit_result.data, exploit_result.access
                        )
                        session_token = self._extract_session_token(
                            exploit_result.data, exploit_result.access
                        )
                        primary_cred = next((c for c in extracted_creds if c.get("username")), None)

                        access = AccessInfo(
                            host=access_host,
                            method=f"exploit:{exploit_result.vuln_type}",
                            privilege_level=self._guess_privilege_level(exploit_result.shell),
                            credentials=self._redact_credential(primary_cred),
                            session_token="***REDACTED***" if session_token else None,
                            notes=self._sanitize_output(exploit_result.evidence or ""),
                        )
                        self.state.add_access(access)

                        if exploit_result.data:
                            self.state.loot.append(
                                {
                                    "type": "data",
                                    "source": exploit_result.vuln_type,
                                    "url": target_url,
                                    "data": exploit_result.data,
                                }
                            )

                        if exploit_result.files:
                            self.state.loot.append(
                                {
                                    "type": "file",
                                    "source": exploit_result.vuln_type,
                                    "url": target_url,
                                    "files": [f.to_dict() for f in exploit_result.files],
                                }
                            )

                        if exploit_result.access:
                            self.state.loot.append(
                                {
                                    "type": "access",
                                    "source": exploit_result.vuln_type,
                                    "url": target_url,
                                    "data": exploit_result.access.to_dict(),
                                }
                            )

                        if extracted_creds:
                            for cred in extracted_creds:
                                if isinstance(cred, dict) and cred.get("username"):
                                    self.state.add_credential(cred)
                                elif isinstance(cred, dict) and cred.get("token"):
                                    self.state.add_credential(cred)

                        findings.append(
                            {
                                "type": "exploit",
                                "severity": severity,
                                "title": f"{exploit_result.vuln_type.upper()} 漏洞利用成功",
                                "url": target_url,
                                "phase": "exploit",
                                "details": exploit_result.to_dict(),
                            }
                        )

                except (OSError, ConnectionError, asyncio.TimeoutError) as e:
                    err = f"利用 {finding.get('type')} 失败: {e}"
                    errors.append(err)
                    self.logger.exception(err)

            return PhaseResult(
                success=success_count > 0 or len(exploitable) == 0,
                phase=PentestPhase.EXPLOIT,
                data={
                    "exploitable_count": len(exploitable),
                    "exploited_count": success_count,
                    "allow_unverified": allow_unverified,
                },
                findings=findings,
                errors=errors,
            )

        except ImportError as e:
            errors.append(f"模块导入失败: {e}")
            self.logger.exception("漏洞利用模块导入失败: %s", e)
            return PhaseResult(
                success=False,
                phase=PentestPhase.EXPLOIT,
                data={},
                findings=findings,
                errors=errors,
            )
        except (OSError, ConnectionError, asyncio.TimeoutError) as e:
            errors.append(str(e))
            self.logger.exception("漏洞利用阶段失败: %s", e)
            return PhaseResult(
                success=False,
                phase=PentestPhase.EXPLOIT,
                data={},
                findings=findings,
                errors=errors,
            )

    @staticmethod
    def _guess_privilege_level(shell_info: Any) -> str:
        """根据 shell 信息推测权限级别"""
        if not shell_info:
            return "unknown"
        privileges = [str(p).lower() for p in (shell_info.privileges or [])]
        if any(p in ("system", "root") for p in privileges):
            return "system"
        if any("admin" in p for p in privileges):
            return "high"
        return "medium"

    def _extract_credentials_from_exploit(self, data: Any, access: Any) -> List[Dict[str, Any]]:
        """从利用结果中提取凭证或令牌"""
        creds: List[Dict[str, Any]] = []

        def _add_cred(item: Dict[str, Any]):
            if not isinstance(item, dict):
                return
            username = item.get("username") or item.get("user") or item.get("login")
            password = item.get("password") or item.get("pass") or item.get("passwd")
            token = item.get("token") or item.get("access_token") or item.get("session")
            if username and password:
                creds.append(
                    {
                        "type": "password",
                        "username": str(username),
                        "password": str(password),
                        "source": "exploit",
                    }
                )
            elif token:
                creds.append({"type": "token", "token": str(token), "source": "exploit"})

        if isinstance(data, dict):
            raw_list = data.get("credentials")
            if isinstance(raw_list, list):
                for item in raw_list:
                    _add_cred(item)

            _add_cred(data)

            for key in ("tokens", "sessions"):
                items = data.get(key)
                if isinstance(items, list):
                    for item in items:
                        _add_cred({"token": item})

        if access and isinstance(getattr(access, "metadata_found", None), dict):
            _add_cred(access.metadata_found)

        deduped = []
        seen: set = set()
        for cred in creds:
            fingerprint = (cred.get("username"), cred.get("password"), cred.get("token"))
            if fingerprint in seen:
                continue
            seen.add(fingerprint)
            deduped.append(cred)

        return deduped

    def _extract_session_token(self, data: Any, access: Any) -> Optional[str]:
        """从利用结果中提取会话令牌"""
        token_keys = ("session", "session_token", "access_token", "jwt", "token")

        if isinstance(data, dict):
            for key in token_keys:
                value = data.get(key)
                if value:
                    return str(value)

        if access and isinstance(getattr(access, "metadata_found", None), dict):
            for key in token_keys:
                value = access.metadata_found.get(key)
                if value:
                    return str(value)

        return None


__all__ = ["ExploitPhaseExecutor"]
