#!/usr/bin/env python3
"""
漏洞利用编排器测试

测试覆盖:
- ExploitOrchestrator 基本功能
- 漏洞排序和筛选
- 并行/顺序执行
- 验证后利用流程
"""

import asyncio
import pytest
from dataclasses import dataclass
from typing import Any, Dict, List, Optional
from unittest.mock import AsyncMock, MagicMock, patch

# 测试导入
from core.exploit.orchestrator import (
    ExploitOrchestrator,
    OrchestratedExploitResult,
    OrchestrationStrategy,
    RankedDetection,
)
from core.exploit.engine import (
    ExploitResult,
    ExploitStatus,
    ExploitType,
)


# ==================== 测试数据 ====================

@dataclass
class MockDetection:
    """模拟检测结果对象（带属性）"""
    vulnerable: bool = True
    vuln_type: str = 'sqli'
    url: str = 'http://test.com/api'
    param: str = 'id'
    payload: str = 'test_payload'
    severity: str = 'high'
    confidence: float = 0.9
    evidence: str = 'Vulnerability detected'
    verified: bool = False
    extra: dict = None

    def __post_init__(self):
        if self.extra is None:
            self.extra = {}


def create_detection(
    vuln_type: str,
    url: str,
    param: str = 'id',
    severity: str = 'high',
    confidence: float = 0.9,
    vulnerable: bool = True
) -> MockDetection:
    """创建测试用漏洞检测结果"""
    return MockDetection(
        vulnerable=vulnerable,
        vuln_type=vuln_type,
        url=url,
        param=param,
        payload="test_payload",
        severity=severity,
        confidence=confidence,
        evidence=f'{vuln_type} detected'
    )


def create_sample_detections() -> List[MockDetection]:
    """创建测试用检测结果列表"""
    return [
        create_detection('sqli', 'http://test.com/api?id=1', severity='CRITICAL', confidence=0.95),
        create_detection('xss', 'http://test.com/search?q=test', severity='HIGH', confidence=0.8),
        create_detection('ssrf', 'http://test.com/fetch?url=test', severity='HIGH', confidence=0.85),
        create_detection('path_traversal', 'http://test.com/file?name=test', severity='MEDIUM', confidence=0.7),
        create_detection('idor', 'http://test.com/user?id=1', severity='MEDIUM', confidence=0.6),
    ]


# ==================== ExploitOrchestrator Tests ====================

class TestExploitOrchestrator:
    """ExploitOrchestrator 测试"""

    @pytest.fixture
    def orchestrator(self):
        """创建测试编排器"""
        return ExploitOrchestrator()

    @pytest.fixture
    def detections(self):
        """创建测试检测结果"""
        return create_sample_detections()

    def test_filter_and_rank(self, orchestrator, detections):
        """测试筛选和排序"""
        ranked = orchestrator._filter_and_rank(detections)

        assert len(ranked) == len(detections)
        # 验证排序：应该按 severity + confidence 排序
        # Critical > High > Medium > Low
        assert ranked[0].detection.vuln_type == 'sqli'  # Critical + 0.95

    def test_filter_non_vulnerable(self, orchestrator):
        """测试过滤非漏洞结果"""
        detections = [
            create_detection('sqli', 'http://test.com/1', vulnerable=True),
            create_detection('xss', 'http://test.com/2', vulnerable=False),
            create_detection('ssrf', 'http://test.com/3', vulnerable=True),
        ]

        ranked = orchestrator._filter_and_rank(detections)

        assert len(ranked) == 2
        assert all(r.detection.vulnerable for r in ranked)

    def test_calculate_score(self, orchestrator):
        """测试评分计算"""
        detection = create_detection('sqli', 'http://test.com', severity='CRITICAL', confidence=0.9)
        score = orchestrator._calculate_score(detection)

        assert score > 0
        # Critical 应该比 High 分数高
        high_detection = create_detection('xss', 'http://test.com', severity='HIGH', confidence=0.9)
        high_score = orchestrator._calculate_score(high_detection)

        assert score > high_score

    def test_top_n_selection(self, orchestrator, detections):
        """测试 Top N 选择"""
        ranked = orchestrator._filter_and_rank(detections)
        top_3 = ranked[:3]

        assert len(top_3) == 3
        # 确保选中的是评分最高的
        all_scores = [orchestrator._calculate_score(d) for d in detections]
        all_scores.sort(reverse=True)

        top_scores = [r.score for r in top_3]
        for score in top_scores:
            assert score in all_scores[:3] or score >= all_scores[2]

    @pytest.mark.asyncio
    async def test_orchestrate_parallel(self, orchestrator, detections):
        """测试并行编排"""
        with patch.object(orchestrator, '_exploit_single', new_callable=AsyncMock) as mock_exploit:
            mock_exploit.return_value = ExploitResult(
                status=ExploitStatus.SUCCESS,
                exploit_type=ExploitType.DATA_EXTRACTION,
                vuln_type='test',
                url='http://test.com'
            )

            result = await orchestrator.orchestrate(
                detections=detections,
                top_n=3,
                verify_first=False,
                strategy=OrchestrationStrategy.PARALLEL
            )

            assert result.success is True
            assert result.attempted == 3
            assert mock_exploit.call_count == 3

    @pytest.mark.asyncio
    async def test_orchestrate_sequential(self, orchestrator, detections):
        """测试顺序编排"""
        call_order = []

        async def track_order(ranked_item, *args, **kwargs):
            # ranked_item 是 RankedDetection，需要访问 .detection
            call_order.append(ranked_item.detection.vuln_type)
            return ExploitResult(
                status=ExploitStatus.SUCCESS,
                exploit_type=ExploitType.DATA_EXTRACTION,
                vuln_type=ranked_item.detection.vuln_type,
                url=ranked_item.detection.url
            )

        with patch.object(orchestrator, '_exploit_single', side_effect=track_order):
            result = await orchestrator.orchestrate(
                detections=detections,
                top_n=3,
                verify_first=False,
                strategy=OrchestrationStrategy.SEQUENTIAL
            )

            # 顺序执行，应该有调用顺序
            assert len(call_order) == 3

    @pytest.mark.asyncio
    async def test_orchestrate_with_verification(self, orchestrator, detections):
        """测试带验证的编排"""
        # 实际方法是 _verify_detections，它会返回过滤后的列表
        # 这里我们通过 mock _get_verifier 来控制验证行为
        with patch.object(orchestrator, '_verify_detections', new_callable=AsyncMock) as mock_verify:
            with patch.object(orchestrator, '_exploit_single', new_callable=AsyncMock) as mock_exploit:
                # 模拟验证后只返回2个结果
                from core.exploit.orchestrator import RankedDetection
                ranked_items = orchestrator._filter_and_rank(detections[:3])
                mock_verify.return_value = ranked_items[:2]  # 只返回前2个

                mock_exploit.return_value = ExploitResult(
                    status=ExploitStatus.SUCCESS,
                    exploit_type=ExploitType.DATA_EXTRACTION,
                    vuln_type='test',
                    url='http://test.com'
                )

                result = await orchestrator.orchestrate(
                    detections=detections[:3],
                    top_n=3,
                    verify_first=True,
                    strategy=OrchestrationStrategy.SEQUENTIAL
                )

                # 只有2个通过验证的会被利用
                assert mock_exploit.call_count == 2

    @pytest.mark.asyncio
    async def test_orchestrate_partial_success(self, orchestrator, detections):
        """测试部分成功场景"""
        call_count = 0

        async def partial_success(ranked_item, *args, **kwargs):
            nonlocal call_count
            call_count += 1
            success = call_count % 2 == 1  # 奇数次成功
            return ExploitResult(
                status=ExploitStatus.SUCCESS if success else ExploitStatus.FAILED,
                exploit_type=ExploitType.DATA_EXTRACTION,
                vuln_type=ranked_item.detection.vuln_type,
                url=ranked_item.detection.url,
                error='' if success else 'Exploit failed'
            )

        with patch.object(orchestrator, '_exploit_single', side_effect=partial_success):
            result = await orchestrator.orchestrate(
                detections=detections,
                top_n=4,
                verify_first=False,
                strategy=OrchestrationStrategy.SEQUENTIAL
            )

            # 应该有部分成功
            assert result.successful == 2
            assert result.attempted == 4

    @pytest.mark.asyncio
    async def test_orchestrate_empty_detections(self, orchestrator):
        """测试空检测列表"""
        result = await orchestrator.orchestrate(
            detections=[],
            top_n=3,
            verify_first=False
        )

        assert result.success is False
        assert result.total_detections == 0
        assert result.attempted == 0

    @pytest.mark.asyncio
    async def test_orchestrate_all_non_vulnerable(self, orchestrator):
        """测试全部非漏洞"""
        detections = [
            create_detection('sqli', 'http://test.com/1', vulnerable=False),
            create_detection('xss', 'http://test.com/2', vulnerable=False),
        ]

        result = await orchestrator.orchestrate(
            detections=detections,
            top_n=3,
            verify_first=False
        )

        assert result.success is False
        assert result.attempted == 0


# ==================== RankedDetection Tests ====================

class TestRankedDetection:
    """RankedDetection 测试"""

    def test_create_ranked_detection(self):
        """测试创建 RankedDetection"""
        detection = create_detection('sqli', 'http://test.com')
        ranked = RankedDetection(
            detection=detection,
            score=0.85,
            rank=1,
            reason='高优先级漏洞'
        )

        assert ranked.detection.vuln_type == 'sqli'
        assert ranked.detection.url == 'http://test.com'
        assert ranked.detection.vulnerable is True
        assert ranked.score == 0.85
        assert ranked.rank == 1

    def test_ranked_detection_attributes(self):
        """测试 RankedDetection 属性"""
        detection = create_detection('xss', 'http://test.com/xss', severity='HIGH', confidence=0.9)
        ranked = RankedDetection(
            detection=detection,
            score=0.75,
            rank=2,
            reason='严重程度:HIGH, 置信度:0.90'
        )

        assert ranked.score == 0.75
        assert ranked.rank == 2
        assert '严重程度' in ranked.reason


# ==================== OrchestrationStrategy Tests ====================

class TestOrchestrationStrategy:
    """OrchestrationStrategy 测试"""

    def test_parallel_strategy(self):
        """测试并行策略枚举"""
        assert OrchestrationStrategy.PARALLEL.value == 'parallel'

    def test_sequential_strategy(self):
        """测试顺序策略枚举"""
        assert OrchestrationStrategy.SEQUENTIAL.value == 'sequential'

    def test_priority_first_strategy(self):
        """测试优先级策略枚举"""
        assert OrchestrationStrategy.PRIORITY_FIRST.value == 'priority_first'


# ==================== OrchestratedExploitResult Tests ====================

class TestOrchestratedExploitResult:
    """OrchestratedExploitResult 测试"""

    def test_success_calculation(self):
        """测试成功状态计算"""
        result = OrchestratedExploitResult(
            success=True,
            total_detections=5,
            attempted=3,
            successful=2,
            failed=1,
            skipped=2,
            results=[],
            total_time_ms=1000
        )

        assert result.success is True
        assert result.successful == 2
        assert result.attempted == 3

    def test_failure_calculation(self):
        """测试失败状态"""
        result = OrchestratedExploitResult(
            success=False,
            total_detections=5,
            attempted=3,
            successful=0,
            failed=3,
            skipped=2,
            results=[],
            total_time_ms=1000
        )

        assert result.success is False
        assert result.failed == 3


# ==================== Integration Tests ====================

class TestOrchestratorIntegration:
    """编排器集成测试"""

    @pytest.mark.asyncio
    async def test_full_orchestration_flow(self):
        """测试完整编排流程"""
        orchestrator = ExploitOrchestrator()
        detections = create_sample_detections()

        # Mock 所有外部调用
        with patch.object(orchestrator, '_exploit_single', new_callable=AsyncMock) as mock_exploit:
            mock_exploit.return_value = ExploitResult(
                status=ExploitStatus.SUCCESS,
                exploit_type=ExploitType.COMMAND_EXECUTION,
                vuln_type='sqli',
                url='http://test.com',
                evidence='SQL injection exploited'
            )

            result = await orchestrator.orchestrate(
                detections=detections,
                top_n=2,
                verify_first=False,
                strategy=OrchestrationStrategy.PARALLEL
            )

            assert result.total_detections == 5
            assert result.attempted == 2
            assert result.successful == 2

    @pytest.mark.asyncio
    async def test_orchestration_with_feedback_engine(self):
        """测试与反馈引擎的集成"""
        from core.feedback import FeedbackLoopEngine

        orchestrator = ExploitOrchestrator()
        feedback_engine = FeedbackLoopEngine(max_retries=2)

        detections = [create_detection('sqli', 'http://test.com')]

        # 模拟需要重试的场景
        attempt = 0

        async def retry_exploit(ranked_item, *args, **kwargs):
            nonlocal attempt
            attempt += 1
            if attempt == 1:
                return ExploitResult(
                    status=ExploitStatus.FAILED,
                    exploit_type=ExploitType.DATA_EXTRACTION,
                    vuln_type='sqli',
                    url='http://test.com',
                    error='WAF blocked'
                )
            return ExploitResult(
                status=ExploitStatus.SUCCESS,
                exploit_type=ExploitType.DATA_EXTRACTION,
                vuln_type='sqli',
                url='http://test.com'
            )

        with patch.object(orchestrator, '_exploit_single', side_effect=retry_exploit):
            # 这里测试的是编排器本身，不是反馈引擎
            # 反馈引擎的集成在 handlers 层
            result = await orchestrator.orchestrate(
                detections=detections,
                top_n=1,
                verify_first=False
            )

            # 编排器本身不重试，所以第一次失败就失败
            assert attempt == 1


# ==================== 运行测试 ====================

if __name__ == '__main__':
    pytest.main([__file__, '-v'])
