#!/usr/bin/env python3
"""
漏洞利用器测试套件

测试覆盖:
- BaseExploiter 基类
- RCEExploiter
- SSTIExploiter
- SSRFExploiter
- XXEExploiter
- IDORExploiter
- DeserializeExploiter
- FileUploadExploiter
"""

import pytest
from dataclasses import dataclass
from typing import Any, Dict, Optional
from unittest.mock import AsyncMock, MagicMock, patch

# 基础导入
from core.exploit.engine import (
    BaseExploiter,
    ExploitResult,
    ExploitStatus,
    ExploitType,
    ShellInfo,
    FileInfo,
    register_exploiter,
)


# ==================== 测试数据 ====================

@dataclass
class MockDetectionResult:
    """模拟漏洞检测结果"""
    vulnerable: bool = True
    vuln_type: str = 'test'
    url: str = 'http://test.com/api'
    param: str = 'id'
    payload: str = 'test_payload'
    evidence: str = 'Vulnerability detected'
    extra: dict = None


# ==================== BaseExploiter Tests ====================

class TestBaseExploiter:
    """BaseExploiter 基类测试"""

    def test_create_result_success(self):
        """测试创建成功结果"""
        class TestExploiter(BaseExploiter):
            name = 'test_exploiter'
            supported_vuln_types = ['test']
            exploit_type = ExploitType.DATA_EXTRACTION

            def exploit(self, detection_result, targets=None, **kwargs):
                return self._create_result(
                    status=ExploitStatus.SUCCESS,
                    vuln_type='test',
                    url='http://test.com',
                    evidence='Test evidence'
                )

        exploiter = TestExploiter()
        result = exploiter.exploit(MockDetectionResult())

        assert result.success is True
        assert result.status == ExploitStatus.SUCCESS

    def test_create_result_failed(self):
        """测试创建失败结果"""
        class TestExploiter(BaseExploiter):
            name = 'test_exploiter'
            supported_vuln_types = ['test']
            exploit_type = ExploitType.DATA_EXTRACTION

            def exploit(self, detection_result, targets=None, **kwargs):
                return self._create_result(
                    status=ExploitStatus.FAILED,
                    vuln_type='test',
                    url='http://test.com',
                    error='Test error'
                )

        exploiter = TestExploiter()
        result = exploiter.exploit(MockDetectionResult())

        assert result.success is False
        assert result.status == ExploitStatus.FAILED
        assert 'error' in result.error.lower() or result.error != ''


# ==================== RCEExploiter Tests ====================

class TestRCEExploiter:
    """RCEExploiter 测试"""

    @pytest.fixture
    def exploiter(self):
        """创建 RCE 利用器"""
        from core.exploit.exploiters.rce_exploiter import RCEExploiter
        return RCEExploiter()

    @pytest.fixture
    def detection(self):
        """创建 RCE 检测结果"""
        return MockDetectionResult(
            vuln_type='rce',
            url='http://test.com/cmd?input=test',
            param='input',
            extra={'os_type': 'unix'}
        )

    def test_exploiter_attributes(self, exploiter):
        """测试利用器属性"""
        assert exploiter.name == 'rce_exploiter'
        assert 'rce' in exploiter.supported_vuln_types
        assert exploiter.exploit_type == ExploitType.COMMAND_EXECUTION

    def test_detect_os_type_unix(self, exploiter):
        """测试 Unix 系统检测"""
        # _detect_os_type 需要 (url, param, payload) 三个参数
        # 根据 payload 特征检测 OS 类型
        os_type = exploiter._detect_os_type(
            'http://test.com/cmd.php?input=test',
            'input',
            "; id"  # Unix 分隔符特征
        )
        assert os_type == 'unix'

    def test_detect_os_type_windows(self, exploiter):
        """测试 Windows 系统检测"""
        # _detect_os_type 根据 URL 扩展名检测 OS 类型
        os_type = exploiter._detect_os_type(
            'http://test.com/cmd.aspx?input=test',
            'input',
            ''  # .aspx 扩展名指示 Windows
        )
        assert os_type == 'windows'

    def test_generate_commands_unix(self, exploiter):
        """测试 Unix 命令存在"""
        # 使用 OS_COMMANDS 属性而非 _generate_commands 方法
        commands = exploiter.OS_COMMANDS.get('unix', {})
        assert 'identity' in commands
        assert any('id' in cmd or 'whoami' in cmd for cmd in commands.get('identity', []))
        # uname -a 在 identity 键下
        assert any('uname' in cmd for cmd in commands.get('identity', []))

    def test_generate_commands_windows(self, exploiter):
        """测试 Windows 命令存在"""
        # 使用 OS_COMMANDS 属性而非 _generate_commands 方法
        commands = exploiter.OS_COMMANDS.get('windows', {})
        assert 'identity' in commands
        assert 'whoami' in commands.get('identity', [])
        assert any('hostname' in cmd or 'ver' in cmd for cmd in commands.get('system_info', []))


# ==================== SSTIExploiter Tests ====================

class TestSSTIExploiter:
    """SSTIExploiter 测试"""

    @pytest.fixture
    def exploiter(self):
        """创建 SSTI 利用器"""
        from core.exploit.exploiters.ssti_exploiter import SSTIExploiter
        return SSTIExploiter()

    @pytest.fixture
    def detection(self):
        """创建 SSTI 检测结果"""
        return MockDetectionResult(
            vuln_type='ssti',
            url='http://test.com/render?template={{7*7}}',
            param='template',
            extra={'template_engine': 'jinja2'}
        )

    def test_exploiter_attributes(self, exploiter):
        """测试利用器属性"""
        assert exploiter.name == 'ssti_exploiter'
        assert 'ssti' in exploiter.supported_vuln_types

    def test_detect_template_engine(self, exploiter):
        """测试模板引擎检测"""
        # _detect_template_engine 只接受 payload 一个参数
        # 测试 Jinja2 特征 payload
        engine = exploiter._detect_template_engine("{{config.__class__.__mro__}}")
        assert engine == 'jinja2'

    def test_jinja2_payloads_exist(self, exploiter):
        """测试 Jinja2 payload 存在"""
        # 使用 TEMPLATE_PAYLOADS 而非 SSTI_PAYLOADS
        payloads = exploiter.TEMPLATE_PAYLOADS.get('jinja2', {})
        assert len(payloads) > 0

    def test_twig_payloads_exist(self, exploiter):
        """测试 Twig payload 存在"""
        # 使用 TEMPLATE_PAYLOADS 而非 SSTI_PAYLOADS
        payloads = exploiter.TEMPLATE_PAYLOADS.get('twig', {})
        assert len(payloads) > 0


# ==================== SSRFExploiter Tests ====================

class TestSSRFExploiter:
    """SSRFExploiter 测试"""

    @pytest.fixture
    def exploiter(self):
        """创建 SSRF 利用器"""
        from core.exploit.exploiters.ssrf_exploiter import SSRFExploiter
        return SSRFExploiter()

    @pytest.fixture
    def detection(self):
        """创建 SSRF 检测结果"""
        return MockDetectionResult(
            vuln_type='ssrf',
            url='http://test.com/fetch?url=http://example.com',
            param='url'
        )

    def test_exploiter_attributes(self, exploiter):
        """测试利用器属性"""
        assert exploiter.name == 'ssrf_exploiter'
        assert 'ssrf' in exploiter.supported_vuln_types

    def test_cloud_metadata_endpoints(self, exploiter):
        """测试云元数据端点存在"""
        endpoints = exploiter.CLOUD_METADATA_ENDPOINTS
        assert 'aws' in endpoints
        assert 'gcp' in endpoints
        assert 'azure' in endpoints

    def test_internal_services(self, exploiter):
        """测试内部服务探测目标存在"""
        services = exploiter.INTERNAL_SERVICES
        assert len(services) > 0


# ==================== XXEExploiter Tests ====================

class TestXXEExploiter:
    """XXEExploiter 测试"""

    @pytest.fixture
    def exploiter(self):
        """创建 XXE 利用器"""
        from core.exploit.exploiters.xxe_exploiter import XXEExploiter
        return XXEExploiter()

    @pytest.fixture
    def detection(self):
        """创建 XXE 检测结果"""
        return MockDetectionResult(
            vuln_type='xxe',
            url='http://test.com/api/xml',
            extra={'os_type': 'unix', 'content_type': 'application/xml'}
        )

    def test_exploiter_attributes(self, exploiter):
        """测试利用器属性"""
        assert exploiter.name == 'xxe_exploiter'
        assert 'xxe' in exploiter.supported_vuln_types
        assert exploiter.exploit_type == ExploitType.FILE_READ

    def test_xxe_payloads_exist(self, exploiter):
        """测试 XXE payload 存在"""
        payloads = exploiter.XXE_PAYLOADS
        assert 'file_read' in payloads
        assert 'ssrf' in payloads
        assert 'oob' in payloads

    def test_target_files_exist(self, exploiter):
        """测试目标文件列表存在"""
        files = exploiter.TARGET_FILES
        assert 'unix' in files
        assert 'windows' in files
        assert '/etc/passwd' in files['unix']

    def test_file_signatures_exist(self, exploiter):
        """测试文件特征存在"""
        signatures = exploiter.FILE_SIGNATURES
        assert '/etc/passwd' in signatures


# ==================== IDORExploiter Tests ====================

class TestIDORExploiter:
    """IDORExploiter 测试"""

    @pytest.fixture
    def exploiter(self):
        """创建 IDOR 利用器"""
        from core.exploit.exploiters.idor_exploiter import IDORExploiter
        return IDORExploiter()

    @pytest.fixture
    def detection(self):
        """创建 IDOR 检测结果"""
        return MockDetectionResult(
            vuln_type='idor',
            url='http://test.com/user?id=123',
            param='id',
            payload='123'
        )

    def test_exploiter_attributes(self, exploiter):
        """测试利用器属性"""
        assert exploiter.name == 'idor_exploiter'
        assert 'idor' in exploiter.supported_vuln_types
        assert exploiter.exploit_type == ExploitType.DATA_EXTRACTION

    def test_generate_test_ids_numeric(self, exploiter):
        """测试数字 ID 生成"""
        test_ids = exploiter._generate_test_ids('100', {})
        assert len(test_ids) > 0
        assert 1 in test_ids  # 管理员 ID
        assert 99 in test_ids or 101 in test_ids  # 相邻 ID

    def test_generate_test_ids_uuid(self, exploiter):
        """测试 UUID 变体生成"""
        uuid_str = '12345678-1234-1234-1234-123456789012'
        test_ids = exploiter._generate_test_ids(uuid_str, {})
        assert len(test_ids) > 0
        # 应包含全零 UUID
        assert '00000000-0000-0000-0000-000000000000' in test_ids

    def test_sensitive_patterns_exist(self, exploiter):
        """测试敏感数据模式存在"""
        patterns = exploiter.SENSITIVE_PATTERNS
        assert 'email' in patterns
        assert 'phone' in patterns
        assert 'credit_card' in patterns

    def test_mask_email(self, exploiter):
        """测试邮箱遮蔽"""
        masked = exploiter._mask_sensitive('test@example.com', 'email')
        assert '@' in masked
        assert 'test' not in masked or masked.startswith('te')


# ==================== DeserializeExploiter Tests ====================

class TestDeserializeExploiter:
    """DeserializeExploiter 测试"""

    @pytest.fixture
    def exploiter(self):
        """创建反序列化利用器"""
        from core.exploit.exploiters.deserialize_exploiter import DeserializeExploiter
        return DeserializeExploiter()

    @pytest.fixture
    def detection(self):
        """创建反序列化检测结果"""
        return MockDetectionResult(
            vuln_type='deserialize',
            url='http://test.com/api',
            param='data',
            extra={'serialize_type': 'php'}
        )

    def test_exploiter_attributes(self, exploiter):
        """测试利用器属性"""
        assert exploiter.name == 'deserialize_exploiter'
        assert 'deserialize' in exploiter.supported_vuln_types
        assert exploiter.exploit_type == ExploitType.COMMAND_EXECUTION

    def test_detect_serialize_type_php(self, exploiter):
        """测试 PHP 序列化检测"""
        payload = 'O:8:"stdClass":0:{}'
        detected = exploiter._detect_serialize_type(payload)
        assert detected == 'php'

    def test_detect_serialize_type_java(self, exploiter):
        """测试 Java 序列化检测"""
        import base64
        # Java 序列化魔术头
        java_magic = b'\xac\xed\x00\x05'
        payload = base64.b64encode(java_magic + b'test').decode()
        detected = exploiter._detect_serialize_type(payload)
        assert detected == 'java'

    def test_php_payloads_exist(self, exploiter):
        """测试 PHP payload 存在"""
        payloads = exploiter.PHP_PAYLOADS
        assert len(payloads) > 0


# ==================== FileUploadExploiter Tests ====================

class TestFileUploadExploiter:
    """FileUploadExploiter 测试"""

    @pytest.fixture
    def exploiter(self):
        """创建文件上传利用器"""
        from core.exploit.exploiters.upload_exploiter import FileUploadExploiter
        return FileUploadExploiter()

    @pytest.fixture
    def detection(self):
        """创建文件上传检测结果"""
        return MockDetectionResult(
            vuln_type='file_upload',
            url='http://test.com/upload',
            param='file',
            extra={'shell_type': 'php'}
        )

    def test_exploiter_attributes(self, exploiter):
        """测试利用器属性"""
        assert exploiter.name == 'file_upload_exploiter'
        assert 'file_upload' in exploiter.supported_vuln_types
        assert exploiter.exploit_type == ExploitType.FILE_WRITE

    def test_webshell_templates_exist(self, exploiter):
        """测试 Webshell 模板存在"""
        templates = exploiter.WEBSHELL_TEMPLATES
        assert 'php' in templates
        assert 'asp' in templates
        assert 'jsp' in templates

    def test_detect_shell_type_php(self, exploiter):
        """测试 PHP shell 类型检测"""
        url = 'http://test.com/upload.php'
        shell_type = exploiter._detect_shell_type(url)
        assert shell_type == 'php'

    def test_detect_shell_type_asp(self, exploiter):
        """测试 ASP shell 类型检测"""
        url = 'http://test.com/upload.asp'
        shell_type = exploiter._detect_shell_type(url)
        assert shell_type == 'asp'

    def test_generate_filenames(self, exploiter):
        """测试文件名生成"""
        filenames = exploiter._generate_filenames('php')
        assert len(filenames) > 0
        # 应包含各种扩展名变体
        assert any('.php' in f for f in filenames)
        assert any('.phtml' in f.lower() or '.php' in f.lower() for f in filenames)

    def test_extension_variants_exist(self, exploiter):
        """测试扩展名变体存在"""
        variants = exploiter.EXTENSION_VARIANTS
        assert 'php' in variants
        assert len(variants['php']) > 1  # 多个变体

    def test_image_headers_exist(self, exploiter):
        """测试图片头存在"""
        headers = exploiter.IMAGE_HEADERS
        assert 'gif' in headers
        assert headers['gif'] == b'GIF89a'


# ==================== Exploiter Registration Tests ====================

class TestExploiterRegistration:
    """利用器注册测试"""

    def test_all_exploiters_registered(self):
        """测试所有利用器已注册"""
        from core.exploit.exploiters import _registered_exploiters

        expected = ['sqli', 'path_traversal', 'rce', 'ssti', 'ssrf', 'xxe', 'idor', 'deserialize', 'file_upload']

        for exp_type in expected:
            assert exp_type in _registered_exploiters, f"Missing exploiter: {exp_type}"


# ==================== 运行测试 ====================

if __name__ == '__main__':
    pytest.main([__file__, '-v'])
