"""
æ¸—é€æµ‹è¯•å·¥å…·æ¨¡å—

åŒ…å«å·¥å…·:
- pentest_phase: åˆ†é˜¶æ®µæ¸—é€æµ‹è¯•
- auto_pentest: å…¨è‡ªåŠ¨æ¸—é€æµ‹è¯•
- generate_report: ç”Ÿæˆæ¸—é€æµ‹è¯•æŠ¥å‘Š
- smart_analyze: æ™ºèƒ½åˆ†æ
"""

import re
import os
import platform
from datetime import datetime
from ._common import PENTEST_PHASES, safe_execute


# å¤±è´¥è®¡æ•°å™¨ - ç”¨äºåˆ¤æ–­æ˜¯å¦åº”è¯¥ä¸­æ­¢æ‰«æ
_failure_counter = {
    "count": 0,
    "network_errors": 0,
    "last_reset": None,
    "threshold": 5,  # è¿ç»­å¤±è´¥Næ¬¡åä¸­æ­¢
    "lock": None
}


def _init_failure_counter():
    """åˆå§‹åŒ–å¤±è´¥è®¡æ•°å™¨çš„çº¿ç¨‹é”"""
    import threading
    if _failure_counter["lock"] is None:
        _failure_counter["lock"] = threading.Lock()


def reset_failure_counter():
    """é‡ç½®å¤±è´¥è®¡æ•°å™¨"""
    _init_failure_counter()
    with _failure_counter["lock"]:
        _failure_counter["count"] = 0
        _failure_counter["network_errors"] = 0
        _failure_counter["last_reset"] = datetime.now()


def record_failure(is_network_error: bool = False):
    """è®°å½•ä¸€æ¬¡å¤±è´¥"""
    _init_failure_counter()
    with _failure_counter["lock"]:
        _failure_counter["count"] += 1
        if is_network_error:
            _failure_counter["network_errors"] += 1


def should_abort_scan() -> bool:
    """åˆ¤æ–­æ˜¯å¦åº”è¯¥ä¸­æ­¢æ‰«æ"""
    _init_failure_counter()
    with _failure_counter["lock"]:
        return _failure_counter["count"] >= _failure_counter["threshold"]


def get_failure_count() -> int:
    """è·å–å½“å‰å¤±è´¥æ¬¡æ•°"""
    _init_failure_counter()
    with _failure_counter["lock"]:
        return _failure_counter["count"]


def get_network_error_suggestions(error_type: str) -> list:
    """æ ¹æ®é”™è¯¯ç±»å‹è¿”å›ç½‘ç»œé—®é¢˜å»ºè®®"""
    suggestions = [
        "1. æ£€æŸ¥ç›®æ ‡URLæ˜¯å¦æ­£ç¡®",
        "2. æ£€æŸ¥ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸",
        "3. å¦‚æœç›®æ ‡åœ¨å†…ç½‘ï¼Œç¡®ä¿VPNå·²è¿æ¥"
    ]
    if "timeout" in error_type.lower():
        suggestions.append("4. ç›®æ ‡å¯èƒ½å“åº”æ…¢ï¼Œå°è¯•å¢åŠ è¶…æ—¶æ—¶é—´")
    if "refused" in error_type.lower():
        suggestions.append("4. ç›®æ ‡æ‹’ç»è¿æ¥ï¼Œå¯èƒ½ç«¯å£æœªå¼€æ”¾æˆ–è¢«é˜²ç«å¢™é˜»æ–­")
    return suggestions


def check_target_reachable(url: str, timeout: int = 10) -> dict:
    """æ£€æŸ¥ç›®æ ‡æ˜¯å¦å¯è¾¾"""
    import requests
    try:
        resp = requests.get(url, timeout=timeout, verify=False, allow_redirects=True)
        return {
            "reachable": True,
            "status_code": resp.status_code,
            "error": None,
            "suggestions": []
        }
    except requests.exceptions.ConnectionError as e:
        return {
            "reachable": False,
            "status_code": None,
            "error": f"è¿æ¥å¤±è´¥: {str(e)[:100]}",
            "suggestions": get_network_error_suggestions("connection")
        }
    except requests.exceptions.Timeout:
        return {
            "reachable": False,
            "status_code": None,
            "error": "è¿æ¥è¶…æ—¶",
            "suggestions": get_network_error_suggestions("timeout")
        }
    except Exception as e:
        return {
            "reachable": False,
            "status_code": None,
            "error": str(e)[:100],
            "suggestions": get_network_error_suggestions("unknown")
        }


def safe_json_response(data: dict) -> dict:
    """ç¡®ä¿å“åº”æ•°æ®å¯ä»¥è¢«JSONåºåˆ—åŒ–"""
    import json
    try:
        json.dumps(data)
        return data
    except (TypeError, ValueError):
        # é€’å½’æ¸…ç†ä¸å¯åºåˆ—åŒ–çš„å¯¹è±¡
        def clean(obj):
            if isinstance(obj, dict):
                return {k: clean(v) for k, v in obj.items()}
            elif isinstance(obj, list):
                return [clean(item) for item in obj]
            elif isinstance(obj, (str, int, float, bool, type(None))):
                return obj
            else:
                return str(obj)
        return clean(data)


def register_pentest_tools(mcp):
    """æ³¨å†Œæ¸—é€æµ‹è¯•å·¥å…·åˆ°MCPæœåŠ¡å™¨"""

    @mcp.tool()
    def pentest_phase(target: str, phase: str = "recon") -> dict:
        """åˆ†é˜¶æ®µæ¸—é€æµ‹è¯• - æ‰§è¡Œå•ä¸ªé˜¶æ®µï¼Œé¿å…è¶…æ—¶

        Args:
            target: ç›®æ ‡URLæˆ–åŸŸå
            phase: é˜¶æ®µåç§° (recon/vuln_basic/vuln_advanced)

        Returns:
            è¯¥é˜¶æ®µçš„æ‰«æç»“æœ
        """
        if phase not in PENTEST_PHASES:
            return {
                "success": False,
                "error": f"ä¸æ”¯æŒçš„é˜¶æ®µ: {phase}",
                "available_phases": list(PENTEST_PHASES.keys()),
                "phase_info": {k: v["name"] for k, v in PENTEST_PHASES.items()}
            }

        # è§£æç›®æ ‡
        if target.startswith("http"):
            from urllib.parse import urlparse
            parsed = urlparse(target)
            domain = parsed.netloc
            url = target
        else:
            domain = target
            url = f"https://{target}"

        report = {
            "target": target,
            "phase": phase,
            "phase_name": PENTEST_PHASES[phase]["name"],
            "start_time": datetime.now().isoformat(),
            "phases": {},
            "findings": [],
            "risk_summary": {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0},
            "attack_paths": [],
            "recommendations": []
        }

        # æ‰§è¡ŒæŒ‡å®šé˜¶æ®µ - ä½¿ç”¨å»¶è¿Ÿå¯¼å…¥
        report = _run_pentest_phase(target, url, domain, phase, report)

        report["end_time"] = datetime.now().isoformat()
        report["overall_risk"] = "CRITICAL" if report["risk_summary"]["critical"] > 0 else \
                                "HIGH" if report["risk_summary"]["high"] > 0 else \
                                "MEDIUM" if report["risk_summary"]["medium"] > 0 else "LOW"

        return {"success": True, "report": report}

    @mcp.tool()
    def auto_pentest(target: str, deep_scan: bool = True) -> dict:
        """å…¨è‡ªåŠ¨æ¸—é€æµ‹è¯• - æ™ºèƒ½åˆ†æç›®æ ‡å¹¶æ‰§è¡Œå®Œæ•´æ¸—é€æµ‹è¯•æµç¨‹

        Args:
            target: ç›®æ ‡URLæˆ–åŸŸå
            deep_scan: æ˜¯å¦æ‰§è¡Œæ·±åº¦æ‰«æ(åŒ…å«CSRF/SSRF/XXEç­‰é«˜çº§æ£€æµ‹)

        æ³¨æ„: æ­¤å‡½æ•°ä½¿ç”¨åˆ†é˜¶æ®µæ‰§è¡Œ+è¶…æ—¶ä¿æŠ¤ï¼Œé¿å…MCPè°ƒç”¨è¶…æ—¶ã€‚
        å¦‚éœ€æ›´ç²¾ç»†æ§åˆ¶ï¼Œè¯·ä½¿ç”¨ pentest_phase() åˆ†é˜¶æ®µæ‰§è¡Œã€‚
        """
        # é‡ç½®å¤±è´¥è®¡æ•°å™¨
        reset_failure_counter()

        report = {
            "target": target,
            "start_time": datetime.now().isoformat(),
            "scan_mode": "deep" if deep_scan else "quick",
            "phases": {},
            "findings": [],
            "risk_summary": {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0},
            "attack_paths": [],
            "recommendations": [],
            "network_status": None,
            "aborted": False
        }

        # è§£æç›®æ ‡
        if target.startswith("http"):
            from urllib.parse import urlparse
            parsed = urlparse(target)
            domain = parsed.netloc
            url = target
        else:
            domain = target
            url = f"https://{target}"

        # ===== ç½‘ç»œå¯è¾¾æ€§é¢„æ£€ =====
        reachability = check_target_reachable(url, timeout=10)
        report["network_status"] = reachability

        if not reachability["reachable"]:
            report["aborted"] = True
            report["abort_reason"] = "ç›®æ ‡ä¸å¯è¾¾"
            report["error"] = reachability["error"]
            report["suggestions"] = reachability["suggestions"]
            report["end_time"] = datetime.now().isoformat()
            report["overall_risk"] = "UNKNOWN"
            return safe_json_response({
                "success": False,
                "error": f"ç›®æ ‡ä¸å¯è¾¾: {reachability['error']}",
                "suggestions": reachability["suggestions"],
                "report": report
            })

        # ===== é˜¶æ®µ1: ä¿¡æ¯æ”¶é›† =====
        report = _run_pentest_phase(target, url, domain, "recon", report)

        # æ£€æŸ¥æ˜¯å¦åº”è¯¥ä¸­æ­¢
        if should_abort_scan():
            report["aborted"] = True
            report["abort_reason"] = f"è¿ç»­å¤±è´¥{get_failure_count()}æ¬¡ï¼Œè‡ªåŠ¨ä¸­æ­¢æ‰«æ"
            report["suggestions"] = get_network_error_suggestions("connection failed")
            report["end_time"] = datetime.now().isoformat()
            report["overall_risk"] = "UNKNOWN"
            return safe_json_response({
                "success": False,
                "error": report["abort_reason"],
                "suggestions": report["suggestions"],
                "report": report
            })

        # ===== é˜¶æ®µ2.5: åŸºäºæŒ‡çº¹çš„å¼±å£ä»¤æ£€æµ‹ =====
        # åˆ©ç”¨é˜¶æ®µ1ä¸­tech_detectçš„ç»“æœè¿›è¡Œé’ˆå¯¹æ€§å¼±å£ä»¤æ£€æµ‹
        report = _run_pentest_phase(target, url, domain, "fingerprint_weak_password", report)

        # ===== é˜¶æ®µ2: åŸºç¡€æ¼æ´æ‰«æ =====
        report = _run_pentest_phase(target, url, domain, "vuln_basic", report)

        # å†æ¬¡æ£€æŸ¥æ˜¯å¦åº”è¯¥ä¸­æ­¢
        if should_abort_scan():
            report["aborted"] = True
            report["abort_reason"] = f"è¿ç»­å¤±è´¥{get_failure_count()}æ¬¡ï¼Œè‡ªåŠ¨ä¸­æ­¢æ‰«æ"
            report["suggestions"] = get_network_error_suggestions("connection failed")
            report["end_time"] = datetime.now().isoformat()
            report["overall_risk"] = "UNKNOWN"
            return safe_json_response({
                "success": False,
                "error": report["abort_reason"],
                "suggestions": report["suggestions"],
                "report": report
            })

        # ===== é˜¶æ®µ3: é«˜çº§æ¼æ´æ£€æµ‹ (æ·±åº¦æ‰«æ) =====
        if deep_scan:
            report = _run_pentest_phase(target, url, domain, "vuln_advanced", report)

        # ===== é˜¶æ®µ4: ç”Ÿæˆå»ºè®® =====
        if report["risk_summary"]["critical"] > 0:
            report["recommendations"].append("ã€ç´§æ€¥ã€‘å‘ç°ä¸¥é‡æ¼æ´ï¼Œå»ºè®®ç«‹å³ä¿®å¤SQLæ³¨å…¥ç­‰é«˜å±æ¼æ´")
        if report["risk_summary"]["high"] > 0:
            report["recommendations"].append("ã€é«˜å±ã€‘å­˜åœ¨æ•æ„Ÿä¿¡æ¯æ³„éœ²ï¼Œå»ºè®®åˆ é™¤æˆ–é™åˆ¶è®¿é—®æ•æ„Ÿæ–‡ä»¶")
        if report["risk_summary"]["medium"] > 0:
            report["recommendations"].append("ã€ä¸­å±ã€‘å­˜åœ¨é…ç½®é—®é¢˜ï¼Œå»ºè®®åŠ å¼ºå®‰å…¨å¤´é…ç½®å’ŒCORSç­–ç•¥")

        report["end_time"] = datetime.now().isoformat()
        report["overall_risk"] = "CRITICAL" if report["risk_summary"]["critical"] > 0 else \
                                "HIGH" if report["risk_summary"]["high"] > 0 else \
                                "MEDIUM" if report["risk_summary"]["medium"] > 0 else "LOW"

        return safe_json_response({"success": True, "report": report})

    @mcp.tool()
    def generate_report(target: str, format: str = "markdown", include_cve: bool = True) -> dict:
        """ç”Ÿæˆæ¸—é€æµ‹è¯•æŠ¥å‘Š - æ‰§è¡Œå®Œæ•´æµ‹è¯•å¹¶ç”Ÿæˆä¸“ä¸šæŠ¥å‘Š

        Args:
            target: ç›®æ ‡URLæˆ–åŸŸå
            format: æŠ¥å‘Šæ ¼å¼ (markdown/json/html/pdf)
            include_cve: æ˜¯å¦åŒ…å«CVEä¿¡æ¯
        """
        # æ‰§è¡Œå®Œæ•´æ¸—é€æµ‹è¯•
        pentest_result = auto_pentest(target)
        if not pentest_result.get("success"):
            return pentest_result

        report_data = pentest_result["report"]

        # è·å–CVEä¿¡æ¯
        cve_info = []
        if include_cve:
            tech_result = report_data.get("phases", {}).get("recon", {}).get("results", {}).get("tech", {})
            if tech_result and tech_result.get("success"):
                tech = tech_result.get("technology", {})
                search_terms = []

                if tech.get("server"):
                    search_terms.append(tech["server"].split("/")[0])
                for cms in tech.get("cms", []):
                    search_terms.append(cms)
                for fw in tech.get("frameworks", []):
                    search_terms.append(fw)

                # æœç´¢ç›¸å…³CVE
                for term in search_terms[:3]:
                    try:
                        from tools.cve_tools import register_cve_tools
                        import requests
                        cve_url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch={term}&resultsPerPage=3"
                        resp = requests.get(cve_url, timeout=10, headers={"User-Agent": "AutoRedTeam/2.0"})
                        if resp.status_code == 200:
                            data = resp.json()
                            for item in data.get("vulnerabilities", [])[:3]:
                                cve = item.get("cve", {})
                                cvss = "N/A"
                                metrics = cve.get("metrics", {})
                                if metrics.get("cvssMetricV31"):
                                    cvss = metrics["cvssMetricV31"][0].get("cvssData", {}).get("baseScore", "N/A")
                                desc = ""
                                for d in cve.get("descriptions", []):
                                    if d.get("lang") == "en":
                                        desc = d.get("value", "")[:100]
                                        break
                                cve_info.append({
                                    "tech": term,
                                    "cve_id": cve.get("id"),
                                    "cvss": cvss,
                                    "summary": desc
                                })
                    except Exception:
                        pass

        report_data["related_cves"] = cve_info

        if format == "markdown":
            md = f"""# æ¸—é€æµ‹è¯•æŠ¥å‘Š

## åŸºæœ¬ä¿¡æ¯
- **ç›®æ ‡**: {report_data['target']}
- **æµ‹è¯•æ—¶é—´**: {report_data['start_time']} ~ {report_data['end_time']}
- **æ•´ä½“é£é™©ç­‰çº§**: {report_data['overall_risk']}
- **æ‰«ææ¨¡å¼**: {report_data.get('scan_mode', 'deep')}

## é£é™©ç»Ÿè®¡
| ç­‰çº§ | æ•°é‡ |
|------|------|
| ä¸¥é‡ | {report_data['risk_summary']['critical']} |
| é«˜å± | {report_data['risk_summary']['high']} |
| ä¸­å± | {report_data['risk_summary']['medium']} |
| ä½å± | {report_data['risk_summary']['low']} |
| ä¿¡æ¯ | {report_data['risk_summary']['info']} |

## å‘ç°çš„é—®é¢˜
"""
            for i, finding in enumerate(report_data['findings'], 1):
                severity_icon = {"critical": "ğŸ”´", "high": "ğŸŸ ", "medium": "ğŸŸ¡", "low": "ğŸŸ¢", "info": "ğŸ”µ"}.get(finding['type'], "âšª")
                md += f"{i}. {severity_icon} [{finding['type'].upper()}] {finding['detail']}\n"

            md += "\n## æ”»å‡»è·¯å¾„å»ºè®®\n"
            for path in report_data['attack_paths']:
                md += f"- {path}\n"

            if cve_info:
                md += "\n## ç›¸å…³CVEæ¼æ´\n"
                md += "| æŠ€æœ¯ | CVEç¼–å· | CVSS | æè¿° |\n"
                md += "|------|---------|------|------|\n"
                for cve in cve_info:
                    md += f"| {cve['tech']} | {cve['cve_id']} | {cve['cvss']} | {cve['summary']} |\n"

            md += "\n## ä¿®å¤å»ºè®®\n"
            for rec in report_data['recommendations']:
                md += f"- {rec}\n"

            md += f"\n---\n*æŠ¥å‘Šç”Ÿæˆæ—¶é—´: {datetime.now().isoformat()}*\n*ç”± AutoRedTeam v2.0 è‡ªåŠ¨ç”Ÿæˆ*"

            return {"success": True, "format": "markdown", "report": md, "raw_data": report_data}

        elif format == "json":
            return {"success": True, "format": "json", "report": report_data}

        else:
            return {"success": False, "error": f"ä¸æ”¯æŒçš„æ ¼å¼: {format}ï¼Œå¯ç”¨: markdown, json"}

    @mcp.tool()
    def smart_analyze(target: str) -> dict:
        """æ™ºèƒ½åˆ†æ - åˆ†æç›®æ ‡å¹¶æ¨èæœ€ä½³æ”»å‡»ç­–ç•¥"""
        analysis = {
            "target": target,
            "target_type": None,
            "attack_surface": [],
            "recommended_tools": [],
            "attack_priority": [],
            "estimated_difficulty": None
        }

        # è§£æç›®æ ‡ç±»å‹
        if target.startswith("http"):
            analysis["target_type"] = "web_application"
        elif re.match(r'^\d+\.\d+\.\d+\.\d+$', target):
            analysis["target_type"] = "ip_address"
        elif re.match(r'^\d+\.\d+\.\d+\.\d+/\d+$', target):
            analysis["target_type"] = "network_range"
        else:
            analysis["target_type"] = "domain"

        # æ ¹æ®ç›®æ ‡ç±»å‹æ¨èæ”»å‡»é¢
        if analysis["target_type"] == "web_application":
            analysis["attack_surface"] = [
                "Webåº”ç”¨æ¼æ´ (SQLi, XSS, CSRF)",
                "æ•æ„Ÿä¿¡æ¯æ³„éœ² (.git, .env, backup)",
                "ç›®å½•éå†å’Œæ–‡ä»¶åŒ…å«",
                "è®¤è¯å’Œä¼šè¯ç®¡ç†",
                "APIå®‰å…¨"
            ]
            analysis["recommended_tools"] = [
                "full_recon - å®Œæ•´ä¾¦å¯Ÿ",
                "vuln_check - æ¼æ´æ£€æµ‹",
                "sqli_detect - SQLæ³¨å…¥æ£€æµ‹",
                "xss_detect - XSSæ£€æµ‹",
                "dir_bruteforce - ç›®å½•æ‰«æ",
                "sensitive_scan - æ•æ„Ÿæ–‡ä»¶æ‰«æ"
            ]
            analysis["attack_priority"] = [
                "1. ä¿¡æ¯æ”¶é›†: æŠ€æœ¯æ ˆè¯†åˆ«ã€ç›®å½•æ‰«æ",
                "2. æ¼æ´æ‰«æ: SQLæ³¨å…¥ã€XSSã€æ•æ„Ÿæ–‡ä»¶",
                "3. æ¼æ´åˆ©ç”¨: æ ¹æ®å‘ç°çš„æ¼æ´è¿›è¡Œåˆ©ç”¨",
                "4. æƒé™æå‡: è·å–æ›´é«˜æƒé™",
                "5. æ•°æ®è·å–: æå–æ•æ„Ÿæ•°æ®"
            ]
            analysis["estimated_difficulty"] = "MEDIUM"

        elif analysis["target_type"] in ["ip_address", "domain"]:
            analysis["attack_surface"] = [
                "å¼€æ”¾ç«¯å£å’ŒæœåŠ¡",
                "WebæœåŠ¡ (å¦‚æœå­˜åœ¨)",
                "ç½‘ç»œæœåŠ¡æ¼æ´",
                "å¼±å£ä»¤"
            ]
            analysis["recommended_tools"] = [
                "port_scan - ç«¯å£æ‰«æ",
                "dns_lookup - DNSæŸ¥è¯¢",
                "subdomain_bruteforce - å­åŸŸåæšä¸¾",
                "http_probe - HTTPæ¢æµ‹"
            ]
            analysis["attack_priority"] = [
                "1. ç«¯å£æ‰«æ: å‘ç°å¼€æ”¾æœåŠ¡",
                "2. æœåŠ¡è¯†åˆ«: ç¡®å®šæœåŠ¡ç‰ˆæœ¬",
                "3. æ¼æ´åŒ¹é…: æŸ¥æ‰¾å·²çŸ¥æ¼æ´",
                "4. æ¼æ´åˆ©ç”¨: å°è¯•åˆ©ç”¨"
            ]
            analysis["estimated_difficulty"] = "MEDIUM-HIGH"

        # å¿«é€Ÿæ¢æµ‹è·å–æ›´å¤šä¿¡æ¯
        try:
            if analysis["target_type"] == "web_application":
                from tools.recon_tools import _tech_detect_impl
                tech = _tech_detect_impl(target)
                if tech.get("success"):
                    tech_info = tech.get("technology", {})
                    if tech_info.get("cms"):
                        analysis["detected_cms"] = tech_info["cms"]
                        for cms in tech_info["cms"]:
                            if cms == "WordPress":
                                analysis["attack_priority"].insert(0, "0. WordPressä¸“é¡¹: wp-adminçˆ†ç ´, æ’ä»¶æ¼æ´, xmlrpcæ”»å‡»")
                            elif cms == "ThinkPHP":
                                analysis["attack_priority"].insert(0, "0. ThinkPHPä¸“é¡¹: RCEæ¼æ´æ£€æµ‹ (5.0.x/5.1.x)")
                    if tech_info.get("cdn"):
                        analysis["has_cdn"] = True
                        analysis["notes"] = ["æ£€æµ‹åˆ°CDNï¼Œå¯èƒ½éœ€è¦ç»•è¿‡æˆ–å¯»æ‰¾çœŸå®IP"]
        except Exception:
            pass

        return {"success": True, "analysis": analysis}

    return ["pentest_phase", "auto_pentest", "generate_report", "smart_analyze"]


def _run_pentest_phase(target: str, url: str, domain: str, phase: str, report: dict) -> dict:
    """æ‰§è¡Œå•ä¸ªæ¸—é€æµ‹è¯•é˜¶æ®µ - å†…éƒ¨å‡½æ•°"""
    single_check_timeout = 15

    def _check_result(result: dict, check_name: str) -> bool:
        """æ£€æŸ¥ç»“æœå¹¶æ›´æ–°å¤±è´¥è®¡æ•°"""
        if result is None:
            record_failure(is_network_error=True)
            return False
        if not result.get("success", False):
            error_msg = str(result.get("error", "")).lower()
            is_network = any(kw in error_msg for kw in [
                "timeout", "connection", "refused", "reset", "unreachable",
                "network", "socket", "dns", "resolve"
            ])
            record_failure(is_network_error=is_network)
            return False
        return True

    # å»¶è¿Ÿå¯¼å…¥å·¥å…·å‡½æ•°
    try:
        from tools.recon_tools import (
            _dns_lookup_impl, _http_probe_impl, _tech_detect_impl,
            _subdomain_bruteforce_impl, _sensitive_scan_impl
        )
        from tools.vuln_tools import (
            _sqli_detect_impl, _xss_detect_impl, _lfi_detect_impl,
            _csrf_detect_impl, _ssrf_detect_impl, _xxe_detect_impl,
            _security_headers_check_impl, _cors_deep_check_impl
        )
    except ImportError:
        # å¦‚æœæ¨¡å—æ‹†åˆ†æœªå®Œæˆï¼Œè¿”å›é”™è¯¯
        report["phases"][phase] = {"status": "error", "error": "å·¥å…·æ¨¡å—æœªå°±ç»ª"}
        return report

    if phase == "recon":
        report["phases"]["recon"] = {"status": "running", "results": {}}

        # DNS
        dns_result = safe_execute(_dns_lookup_impl, domain, timeout_sec=single_check_timeout)
        report["phases"]["recon"]["results"]["dns"] = dns_result
        _check_result(dns_result, "dns")
        if dns_result and dns_result.get("success"):
            report["findings"].append({"phase": "recon", "type": "info", "detail": f"DNSè§£ææˆåŠŸ: {dns_result.get('records', [])}"})

        if should_abort_scan():
            report["phases"]["recon"]["status"] = "aborted"
            return report

        # HTTPæ¢æµ‹
        http_result = safe_execute(_http_probe_impl, url, timeout_sec=single_check_timeout)
        report["phases"]["recon"]["results"]["http"] = http_result
        _check_result(http_result, "http")
        if http_result and http_result.get("success"):
            report["findings"].append({"phase": "recon", "type": "info", "detail": f"HTTPçŠ¶æ€: {http_result.get('status_code')}, Server: {http_result.get('server')}"})

        if should_abort_scan():
            report["phases"]["recon"]["status"] = "aborted"
            return report

        # æŠ€æœ¯æ ˆè¯†åˆ«
        tech_result = safe_execute(_tech_detect_impl, url, timeout_sec=single_check_timeout)
        report["phases"]["recon"]["results"]["tech"] = tech_result
        if tech_result and tech_result.get("success"):
            tech = tech_result.get("technology", {})
            if tech.get("cms"):
                report["findings"].append({"phase": "recon", "type": "info", "detail": f"æ£€æµ‹åˆ°CMS: {tech['cms']}"})
                for cms in tech["cms"]:
                    if cms == "WordPress":
                        report["attack_paths"].append("WordPress: å°è¯• /wp-admin, xmlrpc.php, æ’ä»¶æ¼æ´")
                    elif cms == "ThinkPHP":
                        report["attack_paths"].append("ThinkPHP: å°è¯• RCEæ¼æ´ (5.xç‰ˆæœ¬)")

        # æ•æ„Ÿæ–‡ä»¶æ‰«æ
        sensitive_result = safe_execute(_sensitive_scan_impl, url, threads=5, timeout_sec=20)
        report["phases"]["recon"]["results"]["sensitive"] = sensitive_result
        if sensitive_result and sensitive_result.get("success") and sensitive_result.get("found"):
            for item in sensitive_result["found"]:
                report["findings"].append({"phase": "recon", "type": "high", "detail": f"æ•æ„Ÿæ–‡ä»¶: {item['url']}"})
                report["risk_summary"]["high"] += 1

        report["phases"]["recon"]["status"] = "completed"

    elif phase == "vuln_basic":
        report["phases"]["vuln_basic"] = {"status": "running", "results": {}}

        # SQLæ³¨å…¥æ£€æµ‹
        sqli_result = safe_execute(_sqli_detect_impl, url, deep_scan=True, timeout_sec=single_check_timeout)
        report["phases"]["vuln_basic"]["results"]["sqli"] = sqli_result
        if sqli_result and sqli_result.get("vulnerable"):
            report["findings"].append({"phase": "vuln", "type": "critical", "detail": f"SQLæ³¨å…¥: {sqli_result.get('injection_type')}"})
            report["risk_summary"]["critical"] += 1
            report["attack_paths"].append("SQLi: å¯å°è¯•æ•°æ®åº“æå–ã€æ–‡ä»¶è¯»å–ã€OSå‘½ä»¤æ‰§è¡Œ")

        # XSSæ£€æµ‹
        xss_result = safe_execute(_xss_detect_impl, url, timeout_sec=single_check_timeout)
        report["phases"]["vuln_basic"]["results"]["xss"] = xss_result
        if xss_result and xss_result.get("vulnerable"):
            report["findings"].append({"phase": "vuln", "type": "high", "detail": "XSSæ¼æ´"})
            report["risk_summary"]["high"] += 1

        # LFIæ£€æµ‹
        lfi_result = safe_execute(_lfi_detect_impl, url, timeout_sec=single_check_timeout)
        report["phases"]["vuln_basic"]["results"]["lfi"] = lfi_result
        if lfi_result and lfi_result.get("vulnerable"):
            report["findings"].append({"phase": "vuln", "type": "high", "detail": "æœ¬åœ°æ–‡ä»¶åŒ…å«æ¼æ´"})
            report["risk_summary"]["high"] += 1

        # å®‰å…¨å¤´æ£€æµ‹
        headers_result = safe_execute(_security_headers_check_impl, url, timeout_sec=single_check_timeout)
        report["phases"]["vuln_basic"]["results"]["headers"] = headers_result
        if headers_result and headers_result.get("missing_headers"):
            for header in headers_result["missing_headers"]:
                report["findings"].append({"phase": "vuln", "type": "medium", "detail": f"ç¼ºå°‘å®‰å…¨å¤´: {header}"})
                report["risk_summary"]["medium"] += 1

        report["phases"]["vuln_basic"]["status"] = "completed"

    elif phase == "vuln_advanced":
        report["phases"]["vuln_advanced"] = {"status": "running", "results": {}}

        # CSRFæ£€æµ‹
        csrf_result = safe_execute(_csrf_detect_impl, url, timeout_sec=single_check_timeout)
        report["phases"]["vuln_advanced"]["results"]["csrf"] = csrf_result
        if csrf_result and csrf_result.get("vulnerable"):
            report["findings"].append({"phase": "vuln", "type": "medium", "detail": "CSRFæ¼æ´"})
            report["risk_summary"]["medium"] += 1

        # SSRFæ£€æµ‹
        ssrf_result = safe_execute(_ssrf_detect_impl, url, timeout_sec=single_check_timeout)
        report["phases"]["vuln_advanced"]["results"]["ssrf"] = ssrf_result
        if ssrf_result and ssrf_result.get("vulnerable"):
            report["findings"].append({"phase": "vuln", "type": "high", "detail": "SSRFæ¼æ´"})
            report["risk_summary"]["high"] += 1

        # XXEæ£€æµ‹
        xxe_result = safe_execute(_xxe_detect_impl, url, timeout_sec=single_check_timeout)
        report["phases"]["vuln_advanced"]["results"]["xxe"] = xxe_result
        if xxe_result and xxe_result.get("vulnerable"):
            report["findings"].append({"phase": "vuln", "type": "high", "detail": "XXEæ¼æ´"})
            report["risk_summary"]["high"] += 1

        # CORSæ£€æµ‹
        cors_result = safe_execute(_cors_deep_check_impl, url, timeout_sec=single_check_timeout)
        report["phases"]["vuln_advanced"]["results"]["cors"] = cors_result
        if cors_result and cors_result.get("vulnerable"):
            report["findings"].append({"phase": "vuln", "type": "medium", "detail": "CORSé…ç½®ä¸å®‰å…¨"})
            report["risk_summary"]["medium"] += 1

        report["phases"]["vuln_advanced"]["status"] = "completed"

    elif phase == "fingerprint_weak_password":
        # é˜¶æ®µ2.5: åŸºäºæŒ‡çº¹çš„å¼±å£ä»¤æ£€æµ‹
        report["phases"]["fingerprint_weak_password"] = {"status": "running", "results": {}}

        # ä» recon é˜¶æ®µè·å–æ£€æµ‹åˆ°çš„ CMS
        detected_cms = []
        recon_results = report.get("phases", {}).get("recon", {}).get("results", {})
        tech_result = recon_results.get("tech", {})
        if tech_result and tech_result.get("success"):
            tech = tech_result.get("technology", {})
            detected_cms = tech.get("cms", [])

        if detected_cms:
            try:
                from core.pipeline import fingerprint_weak_password_detect
                for cms in detected_cms[:3]:  # é™åˆ¶æœ€å¤šæµ‹è¯•3ä¸ªCMS
                    weak_result = safe_execute(
                        fingerprint_weak_password_detect,
                        url, cms, True, 10,
                        timeout_sec=30
                    )
                    report["phases"]["fingerprint_weak_password"]["results"][cms] = weak_result
                    if weak_result and weak_result.get("success"):
                        for cred in weak_result.get("weak_credentials", []):
                            report["findings"].append({
                                "phase": "fingerprint_weak_password",
                                "type": "critical",
                                "detail": f"{cred['cms']} å¼±å£ä»¤: {cred['username']}:{cred['password']}",
                                "endpoint": cred.get("url"),
                                "auth_type": cred.get("auth_type")
                            })
                            report["risk_summary"]["critical"] += 1
                            report["attack_paths"].append(
                                f"{cred['cms']}: ä½¿ç”¨å¼±å£ä»¤ç™»å½• {cred.get('url', '')}"
                            )
                        for panel in weak_result.get("exposed_panels", []):
                            report["findings"].append({
                                "phase": "fingerprint_weak_password",
                                "type": "medium",
                                "detail": f"{panel['cms']} é¢æ¿æš´éœ²: {panel['url']}"
                            })
                            report["risk_summary"]["medium"] += 1
            except ImportError:
                report["phases"]["fingerprint_weak_password"]["error"] = "pipelineæ¨¡å—æœªå°±ç»ª"
        else:
            report["phases"]["fingerprint_weak_password"]["results"]["note"] = "æœªæ£€æµ‹åˆ°CMSï¼Œè·³è¿‡é’ˆå¯¹æ€§å¼±å£ä»¤æ£€æµ‹"

        report["phases"]["fingerprint_weak_password"]["status"] = "completed"

    return report
